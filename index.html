<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPOK ROYALE</title>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Rubik+Glitch&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121212;
            --concrete: #2a2a2a;
            --accent: #FF0055;
            --neon-blue: #00F3FF;
            --neon-green: #00FF66;
            --ui-font: 'Audiowide', cursive;
            --title-font: 'Rubik Glitch', system-ui;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
        }

        body {
            background-color: var(--bg-color);
            color: white;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            font-family: var(--ui-font);
        }

        /* 
           LAYER SYSTEM:
           Z-0: Concrete Texture (CSS/Image)
           Z-1: Paint Canvas (Persistent Splatters)
           Z-2: Game Canvas (Active Players)
           Z-10: UI Layer
        */

        #texture-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background-color: var(--concrete);
            background-image:
                radial-gradient(transparent 0%, #111 100%),
                url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #paint-canvas {
            z-index: 1;
            filter: contrast(1.2) brightness(1.1);
            /* Make paint pop */
        }

        #game-canvas {
            z-index: 2;
        }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            /* Let clicks pass through usually */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Setup Panel */
        .panel {
            pointer-events: auto;
            background: rgba(20, 20, 20, 0.9);
            border: 4px solid #fff;
            box-shadow: 10px 10px 0px rgba(0, 0, 0, 0.5);
            padding: 2.5rem;
            width: 90%;
            max-width: 600px;
            text-align: center;
            transform: rotate(-1deg);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .panel h1 {
            font-family: var(--title-font);
            font-size: 4rem;
            margin-bottom: 0.5rem;
            color: white;
            text-shadow: 4px 4px 0px var(--accent);
            line-height: 1;
            transform: scale(1.1);
        }

        .panel p {
            font-family: var(--ui-font);
            color: #888;
            margin-bottom: 2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 0.8rem;
        }

        textarea {
            width: 100%;
            height: 180px;
            background: #000;
            border: 2px solid #333;
            color: var(--neon-green);
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 1.1rem;
            padding: 1rem;
            margin-bottom: 2rem;
            resize: none;
            outline: none;
        }

        textarea:focus {
            border-color: var(--neon-blue);
        }

        .btn {
            background: #fff;
            color: #000;
            border: none;
            padding: 1rem 3rem;
            font-family: var(--ui-font);
            font-size: 1.5rem;
            font-weight: 900;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 5px 5px 0px var(--accent);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn:hover {
            transform: translate(-2px, -2px);
            box-shadow: 7px 7px 0px var(--accent);
            background: var(--neon-blue);
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: 1px 1px 0px var(--accent);
        }

        /* HUD */
        #hud-top {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 2rem;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s;
            z-index: 20;
        }

        #phase-indicator {
            position: absolute;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            text-shadow: 0 0 10px var(--accent);
            z-index: 25;
            display: none;
        }

        .counter {
            background: #000;
            color: #fff;
            padding: 0.5rem 1.5rem;
            font-size: 1.5rem;
            border: 2px solid white;
            box-shadow: 4px 4px 0px var(--neon-blue);
            transform: skew(-10deg);
            display: flex;
            align-items: center;
            justify-content: center;
            height: fit-content;
        }

        .kill-feed {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-end;
        }

        .kill-msg {
            background: #000;
            color: #fff;
            padding: 0.5rem 1rem;
            border-left: 5px solid;
            font-size: 1rem;
            font-family: monospace;
            text-transform: uppercase;
            animation: slideIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* Win Screen */
        #win-overlay {
            opacity: 0;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            transition: opacity 0.5s;
        }

        #win-title {
            font-family: var(--title-font);
            font-size: 8rem;
            line-height: 1;
            margin-bottom: 2rem;
            color: white;
            text-shadow: 10px 10px 0px var(--neon-green);
            transform: rotate(-5deg);
        }

        .hidden {
            display: none !important;
        }

        .visible {
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        @keyframes slideIn {
            from {
                transform: translateX(50px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>

<body>

    <div id="texture-layer"></div>
    <canvas id="paint-canvas"></canvas>
    <canvas id="game-canvas"></canvas>

    <div id="ui-layer">
        <!-- SETUP -->
        <div id="setup-panel" class="panel">
            <h1>EPOK<br>ROYALE</h1>
            <p>Qui laissera sa trace ?</p>
            <textarea id="name-input" spellcheck="false">GHOST
BLADE
NEON
VIPER
SHADE</textarea>
            <div style="margin-bottom: 2rem; display: flex; gap: 1rem; justify-content: center;">
                <button class="btn" id="start-btn">JOUER</button>
                <button class="btn" id="import-btn" title="Importer CSV"
                    style="background: #222; color: #fff; padding: 1rem; aspect-ratio: 1/1; display: flex; align-items: center; justify-content: center; box-shadow: 5px 5px 0px #444;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </button>
            </div>
            <input type="file" id="csv-input" accept=".csv, .txt" style="display: none;" multiple>
        </div>

        <!-- WIN -->
        <div id="win-overlay" class="panel visible hidden"
            style="background: transparent; border: none; box-shadow: none;">
            <div id="win-title">GAGNANT</div>
            <button class="btn" id="restart-btn">REJOUER</button>
        </div>
    </div>

    <div id="hud-top">
        <div class="counter" id="alive-cnt">5 RESTANTS</div>
        <div id="phase-indicator">WARMUP</div>
        <div class="kill-feed" id="kill-feed"></div>
    </div>

    <script>
        const CONFIG = {
            minSpeed: 3,
            maxSpeed: 7,
            drag: 1.0,
            radius: 20,
            colors: ['#FF0055', '#00F3FF', '#39FF14', '#FFFF00', '#BE00FF', '#FF6600'],
            crews: {
                cyan: '#00F3FF',
                magenta: '#FF1493' // Hot Pink
            },
            traitorGold: '#FFD700'
        };

        const $ = id => document.getElementById(id);
        const rand = (min, max) => Math.random() * (max - min) + min;
        const randInt = (min, max) => Math.floor(rand(min, max));
        const randColor = () => CONFIG.colors[randInt(0, CONFIG.colors.length)];

        class Game {
            constructor() {
                this.gameCanvas = $('game-canvas');
                this.paintCanvas = $('paint-canvas');
                this.gCtx = this.gameCanvas.getContext('2d');
                this.pCtx = this.paintCanvas.getContext('2d');

                this.width = window.innerWidth;
                this.height = window.innerHeight;

                this.players = [];
                this.particles = []; // For transient effects like sparks
                this.running = false;
                this.gracePeriod = 0;

                // Slow-motion system for suspense
                this.slowMotion = false;
                this.slowMotionFactor = 0.3; // How slow (0.3 = 30% speed)
                this.slowMotionDelay = 0; // Frames to wait before turning off
                this.slowMotionDelayFrames = 30; // ~0.5 seconds at 60fps
                this.playerDistances = new Map(); // Track previous distances

                this.gameState = 'TEAMS'; // 'TEAMS', 'TRANSITION', 'FFA'
                this.dangerZone = null; // {x, y, w, h}

                window.addEventListener('resize', () => this.resize());
                this.resize();

                // Bind UI
                $('start-btn').onclick = () => this.start();
                $('restart-btn').onclick = () => this.reset();
                $('import-btn').onclick = () => $('csv-input').click();
                $('csv-input').onchange = (e) => this.handleFileUpload(e);

                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;

                this.gameCanvas.width = this.width;
                this.gameCanvas.height = this.height;

                // We don't want to clear paint on resize usually, but for simplicity let's just resize
                // A better approach would be to copy the old canvas, but let's keep it simple
                this.paintCanvas.width = this.width;
                this.paintCanvas.height = this.height;
            }

            reset() {
                this.running = false;
                $('setup-panel').classList.remove('hidden');
                $('win-overlay').classList.add('hidden');
                $('hud-top').classList.remove('visible');
                $('phase-indicator').style.display = 'none';

                // Clear Everything
                this.pCtx.clearRect(0, 0, this.width, this.height);
                this.gCtx.clearRect(0, 0, this.width, this.height);
                $('kill-feed').innerHTML = '';
            }

            start() {
                const playerEntries = $('name-input').value.split('\n').filter(n => n.trim().length > 0);
                if (playerEntries.length < 2) return alert("NEED MORE PLAYERS");

                this.players = [];
                this.gameState = 'TEAMS';
                this.dangerZone = null;

                // Shuffle names to randomize teams
                const shuffledEntries = this.shuffleArray([...playerEntries]);
                const mid = Math.ceil(shuffledEntries.length / 2);

                shuffledEntries.forEach((entry, index) => {
                    const team = index < mid ? 'cyan' : 'magenta';
                    let id, name;
                    const parts = entry.split(',').map(p => p.trim());
                    if (parts.length === 2) {
                        id = parts[0];
                        name = parts[1];
                    } else {
                        id = `P${index + 1}`;
                        name = parts[0];
                    }

                    const pos = this.getSafeSpawnPosition(this.players);
                    if (pos) {
                        this.players.push(new Player(id, name, pos.x, pos.y, team));
                    } else {
                        this.players.push(new Player(id, name, rand(100, this.width - 100), rand(100, this.height - 100), team));
                    }
                });

                $('setup-panel').classList.add('hidden');
                $('hud-top').classList.add('visible');
                this.updateCount();

                this.gracePeriod = 300; // 5 seconds approx at 60fps
                this.updatePhaseUI();

                this.running = true;
            }

            updatePhaseUI() {
                const el = $('phase-indicator');
                if (this.gracePeriod > 0) {
                    el.innerText = "PREPAREZ VOUS !"; // WARMUP
                    el.style.color = CONFIG.colors[2]; // Green
                    el.style.display = 'block';
                } else {
                    el.innerText = "COMBAT"; // FIGHT
                    el.style.color = CONFIG.colors[0]; // Red
                    setTimeout(() => el.style.display = 'none', 1000);
                }
            }

            getSafeSpawnPosition(existingPlayers) {
                const maxAttempts = 100;
                const buffer = 50; // Extra space between balls

                for (let i = 0; i < maxAttempts; i++) {
                    const x = rand(100, this.width - 100);
                    const y = rand(100, this.height - 100);

                    let valid = true;
                    for (let p of existingPlayers) {
                        const dist = Math.hypot(x - p.x, y - p.y);
                        // 2 * radius + buffer
                        if (dist < (CONFIG.radius * 2) + buffer) {
                            valid = false;
                            break;
                        }
                    }

                    if (valid) return { x, y };
                }
                return null; // Failed to find spot
            }

            updateCount() {
                const alive = this.players.filter(p => !p.dead).length;
                $('alive-cnt').innerText = `${alive} RESTANTS`;
            }

            logKill(winner, loser) {
                const div = document.createElement('div');
                div.className = 'kill-msg';
                div.style.borderColor = winner.color;
                div.innerHTML = `<span style="color:${winner.color}">${winner.name}</span> SPLATTED <span style="color:#888">${loser.name}</span>`;
                $('kill-feed').prepend(div);
                setTimeout(() => div.remove(), 4000);
            }

            loop() {
                // Clear Game Canvas only (Paint persists)
                this.gCtx.clearRect(0, 0, this.width, this.height);

                if (this.running) {
                    // Game Logic
                    if (this.gracePeriod > 0) {
                        this.gracePeriod--;
                        if (this.gracePeriod === 0) this.updatePhaseUI();
                    }

                    // Check for slow-motion trigger (under 10 players)
                    this.updateSlowMotion();

                    // Apply slow-motion by running updates multiple times or adjusting speeds
                    const updateIterations = this.slowMotion ? 1 : 1;
                    const speedMultiplier = this.slowMotion ? this.slowMotionFactor : 1.0;

                    this.players.forEach(p => p.update(this, speedMultiplier));
                    this.checkCollisions();

                    if (this.gameState === 'FFA') this.drawDangerZone();

                    // Render Players
                    this.players.forEach(p => p.draw(this.gCtx));
                }

                // Render Particles (Transient)
                this.gCtx.globalCompositeOperation = 'lighter';
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.update();
                    p.draw(this.gCtx);
                    if (p.life <= 0) this.particles.splice(i, 1);
                }
                this.gCtx.globalCompositeOperation = 'source-over';

                requestAnimationFrame(this.loop);
            }

            updateSlowMotion() {
                const active = this.players.filter(p => !p.dead);

                // Only when under 10 players and combat has started, and NOT in transition
                if (active.length >= 10 || this.gracePeriod > 0 || this.gameState === 'TRANSITION') {
                    this.slowMotion = false;
                    this.playerDistances.clear();
                    return;
                }

                let shouldSlowDown = false;
                const dangerThreshold = this.gameState === 'TEAMS' ? 60 : 100; // Increased distance threshold for FFA

                // Check all pairs of players
                for (let i = 0; i < active.length; i++) {
                    for (let j = i + 1; j < active.length; j++) {
                        const p1 = active[i];
                        const p2 = active[j];

                        // Skip slow-motion for teammates
                        if (this.gameState === 'TEAMS' && p1.team === p2.team) continue;

                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const dist = Math.hypot(dx, dy);

                        // Create unique pair ID
                        const pairId = `${p1.id}_${p2.id}`;
                        const prevDist = this.playerDistances.get(pairId);

                        // Store current distance
                        this.playerDistances.set(pairId, dist);

                        // Check if players are close AND getting closer
                        if (dist < dangerThreshold && prevDist !== undefined && dist < prevDist) {
                            shouldSlowDown = true;
                        }
                    }
                }

                // Handle slow-motion state with delay
                if (shouldSlowDown) {
                    this.slowMotion = true;
                    this.slowMotionDelay = this.slowMotionDelayFrames; // Reset delay
                } else if (this.slowMotion) {
                    // Countdown delay before turning off
                    this.slowMotionDelay--;
                    if (this.slowMotionDelay <= 0) {
                        this.slowMotion = false;
                    }
                }
            }

            checkCollisions() {
                const active = this.players.filter(p => !p.dead);

                for (let i = 0; i < active.length; i++) {
                    for (let j = i + 1; j < active.length; j++) {
                        const p1 = active[i];
                        const p2 = active[j];

                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const dist = Math.hypot(dx, dy);
                        const minDist = p1.radius + p2.radius;

                        if (dist < minDist) {
                            if (this.gracePeriod > 0) {
                                // Elastic Collision (Peace Phase)
                                this.resolveElastic(p1, p2, dx, dy, dist);
                            } else {
                                // Combat Phase - Depends on Game State
                                if (this.gameState === 'TEAMS') {
                                    if (p1.team === p2.team) {
                                        this.resolveElastic(p1, p2, dx, dy, dist);
                                    } else {
                                        if (p1.cooldown <= 0 && p2.cooldown <= 0) {
                                            this.resolveCombat(p1, p2);
                                        }
                                    }
                                } else if (this.gameState === 'FFA') {
                                    if (p1.cooldown <= 0 && p2.cooldown <= 0) {
                                        this.resolveCombat(p1, p2);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            resolveElastic(p1, p2, dx, dy, dist) {
                // 1. Separate circles to prevent sticky glitches
                const overlap = (p1.radius + p2.radius - dist) / 2;
                const offsetX = (dx / dist) * overlap;
                const offsetY = (dy / dist) * overlap;

                p1.x += offsetX;
                p1.y += offsetY;
                p2.x -= offsetX;
                p2.y -= offsetY;

                // 2. Reflect Velocity (Elastic Collision)
                // Normal vector
                const nx = dx / dist;
                const ny = dy / dist;

                // Relative velocity
                const dvx = p1.vx - p2.vx;
                const dvy = p1.vy - p2.vy;

                // Velocity along normal
                const velAlongNormal = dvx * nx + dvy * ny;

                // Do not resolve if velocities are separating
                if (velAlongNormal > 0) return;

                // Restitution (bounciness) 1 = perfect elastic
                const restitution = 1;

                // Impulse scalar
                const j = -(1 + restitution) * velAlongNormal / 2; // /2 assuming equal mass

                // Apply impulse
                p1.vx += j * nx;
                p1.vy += j * ny;
                p2.vx -= j * nx;
                p2.vy -= j * ny;
            }

            resolveCombat(p1, p2) {
                // RNG Winner
                const winner = Math.random() > 0.5 ? p1 : p2;
                const loser = winner === p1 ? p2 : p1;

                // Eliminate Loser
                loser.dead = true;

                // HUGE SPLAT
                this.drawSplat(loser.x, loser.y, loser.color, 80, 50); // Big messy splat
                this.spawnParticles(loser.x, loser.y, loser.color, 30); // Sparks

                // Buff Winner
                winner.radius += 5;
                winner.cooldown = 20;

                // Bounce Winner
                const angle = Math.atan2(winner.y - loser.y, winner.x - loser.x);
                winner.vx = Math.cos(angle) * 8;
                winner.vy = Math.sin(angle) * 8;

                this.logKill(winner, loser);
                this.updateCount();

                // Check Win conditions
                const active = this.players.filter(p => !p.dead);

                if (this.gameState === 'TEAMS') {
                    const teamsRemaining = new Set(active.map(p => p.team));
                    if (teamsRemaining.size === 1) {
                        this.transitionToPhase2();
                    }
                } else if (this.gameState === 'FFA' && active.length === 1) {
                    this.endGame(active[0]);
                }
            }

            endGame(winner) {
                this.running = false;
                setTimeout(() => {
                    $('win-title').innerHTML = winner.name + "<br>WINS";
                    $('win-title').style.textShadow = `10px 10px 0px ${winner.color}`;
                    $('win-overlay').classList.remove('hidden');
                    $('win-overlay').classList.add('visible');

                    // Final celebration splats
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => {
                            this.drawSplat(
                                rand(this.width * 0.2, this.width * 0.8),
                                rand(this.height * 0.2, this.height * 0.8),
                                winner.color, 120, 100
                            );
                        }, i * 200);
                    }
                }, 1000);
            }

            transitionToPhase2() {
                this.gameState = 'TRANSITION';
                const el = $('phase-indicator');
                el.innerText = "VICTORY... BUT THERE CAN BE ONLY ONE.";
                el.style.color = CONFIG.traitorGold;
                el.style.display = 'block';
                el.style.fontSize = '3rem';
                el.style.width = '80%';
                el.style.textAlign = 'center';

                // Calculate Danger Zone
                const zoneW = this.width * 0.5;
                const zoneH = this.height * 0.5;
                this.dangerZone = {
                    x: (this.width - zoneW) / 2,
                    y: (this.height - zoneH) / 2,
                    w: zoneW,
                    h: zoneH
                };

                setTimeout(() => {
                    const active = this.players.filter(p => !p.dead);
                    active.forEach(p => {
                        // Teleport to center area
                        p.x = this.width / 2 + rand(-50, 50);
                        p.y = this.height / 2 + rand(-50, 50);
                        p.color = CONFIG.traitorGold;
                        p.team = null; // Everyone is an enemy now

                        // Give some initial velocity
                        const angle = Math.random() * Math.PI * 2;
                        const speed = rand(CONFIG.minSpeed, CONFIG.maxSpeed);
                        p.vx = Math.cos(angle) * speed;
                        p.vy = Math.sin(angle) * speed;
                    });

                    this.gameState = 'FFA';
                    el.innerText = "BETRAYAL";
                    setTimeout(() => el.style.display = 'none', 2000);
                }, 3000);
            }

            drawDangerZone() {
                if (!this.dangerZone) return;
                const ctx = this.gCtx;
                const z = this.dangerZone;

                ctx.save();

                // Outer Glow for Danger Zone
                ctx.shadowBlur = 20;
                ctx.shadowColor = CONFIG.traitorGold;

                // Draw multiple layers for "hand-drawn/rough" effect
                for (let layer = 0; layer < 3; layer++) {
                    ctx.strokeStyle = layer === 0 ? "rgba(255,255,255,0.8)" : CONFIG.traitorGold;
                    ctx.lineWidth = layer === 0 ? 6 : 2;
                    ctx.beginPath();

                    const jitter = 4 - layer;
                    const steps = 30;

                    // Helper for rough lines
                    const roughLine = (x1, y1, x2, y2) => {
                        ctx.moveTo(x1 + rand(-jitter, jitter), y1 + rand(-jitter, jitter));
                        for (let i = 1; i <= steps; i++) {
                            const tx = x1 + (x2 - x1) * (i / steps) + rand(-jitter, jitter);
                            const ty = y1 + (y2 - y1) * (i / steps) + rand(-jitter, jitter);
                            ctx.lineTo(tx, ty);
                        }
                    };

                    roughLine(z.x, z.y, z.x + z.w, z.y); // Top
                    roughLine(z.x + z.w, z.y, z.x + z.w, z.y + z.h); // Right
                    roughLine(z.x + z.w, z.y + z.h, z.x, z.y + z.h); // Bottom
                    roughLine(z.x, z.y + z.h, z.x, z.y); // Left

                    ctx.stroke();
                }

                ctx.restore();
            }

            drawSplat(x, y, color, size, count) {
                const ctx = this.pCtx;
                ctx.fillStyle = color;

                // Main blob
                ctx.beginPath();
                ctx.arc(x, y, size * 0.4, 0, Math.PI * 2);
                ctx.fill();

                // Random splatters around
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * size;
                    const r = Math.random() * (size * 0.2);

                    ctx.beginPath();
                    ctx.arc(
                        x + Math.cos(angle) * dist,
                        y + Math.sin(angle) * dist,
                        r, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }

            spawnParticles(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }

            async handleFileUpload(e) {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;

                const allPlayerEntries = [];

                for (const file of files) {
                    const text = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (event) => resolve(event.target.result);
                        reader.onerror = (error) => reject(error);
                        reader.readAsText(file);
                    });

                    const lines = text.split('\n').filter(line => line.trim().length > 0);
                    if (lines.length < 2) continue;

                    // Parse header to find column indices
                    const header = lines[0].split(',').map(col => col.replace(/"/g, '').trim());
                    const orderIdIndex = header.indexOf('Order ID');
                    const billingNameIndex = header.indexOf('Billing Name');

                    if (orderIdIndex === -1 || billingNameIndex === -1) {
                        console.warn(`File ${file.name} missing required columns.`);
                        continue;
                    }

                    // Process each data row (skip header)
                    for (let i = 1; i < lines.length; i++) {
                        const row = this.parseCSVLine(lines[i]);
                        if (row.length <= Math.max(orderIdIndex, billingNameIndex)) continue;

                        let orderId = row[orderIdIndex].replace(/"/g, '').trim();
                        const billingName = row[billingNameIndex].replace(/"/g, '').trim();

                        if (!billingName || !orderId) continue;

                        // Remove leading zeros from order ID
                        orderId = parseInt(orderId, 10).toString();

                        // Parse the name
                        const nameParts = billingName.split(' ').filter(p => p.length > 0);
                        if (nameParts.length === 0) continue;

                        const firstName = nameParts[0];
                        const lastPart = nameParts.length > 1 ? nameParts[nameParts.length - 1] : '';
                        const firstLetter = firstName.charAt(0).toUpperCase();

                        const displayName = firstName;
                        const formattedEntry = `${displayName} ${firstLetter}#${orderId}`;

                        allPlayerEntries.push(formattedEntry);
                    }
                }

                if (allPlayerEntries.length === 0) {
                    alert('No valid player entries found in selected files');
                } else {
                    const currentText = $('name-input').value.trim();
                    const newText = currentText ? currentText + '\n' + allPlayerEntries.join('\n') : allPlayerEntries.join('\n');
                    $('name-input').value = newText;
                }

                // Reset file input
                e.target.value = '';
            }

            parseCSVLine(line) {
                // Simple CSV parser that handles quoted fields
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];

                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }

                result.push(current); // Add last field
                return result;
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
        }

        class Player {
            constructor(id, name, x, y, team = null) {
                this.id = id;
                this.name = name;
                this.radius = CONFIG.radius;
                this.team = team;
                this.color = team ? CONFIG.crews[team] : randColor();
                this.x = x;
                this.y = y;

                const angle = Math.random() * Math.PI * 2;
                const speed = rand(CONFIG.minSpeed, CONFIG.maxSpeed);
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;

                this.dead = false;
                this.cooldown = 0;
            }

            update(game, speedMultiplier = 1.0) {
                if (this.dead) return;

                // Move (with slow-motion support)
                this.x += this.vx * speedMultiplier;
                this.y += this.vy * speedMultiplier;

                // Wall Bounce
                const bounds = (game.gameState === 'FFA' && game.dangerZone) ?
                    { xmin: game.dangerZone.x, xmax: game.dangerZone.x + game.dangerZone.w, ymin: game.dangerZone.y, ymax: game.dangerZone.y + game.dangerZone.h } :
                    { xmin: 0, xmax: game.width, ymin: 0, ymax: game.height };

                if (this.x < bounds.xmin + this.radius) { this.x = bounds.xmin + this.radius; this.vx *= -1; }
                if (this.x > bounds.xmax - this.radius) { this.x = bounds.xmax - this.radius; this.vx *= -1; }
                if (this.y < bounds.ymin + this.radius) { this.y = bounds.ymin + this.radius; this.vy *= -1; }
                if (this.y > bounds.ymax - this.radius) { this.y = bounds.ymax - this.radius; this.vy *= -1; }

                // Paint Trail (Frequency check to save perf if needed, but per-frame is smoother)
                if (Math.random() > 0.1) {
                    game.pCtx.fillStyle = this.color;
                    game.pCtx.beginPath();
                    game.pCtx.arc(this.x, this.y, this.radius * 0.8, 0, Math.PI * 2);
                    game.pCtx.fill();

                    // Occasional drip
                    if (Math.random() > 0.9) {
                        game.pCtx.beginPath();
                        game.pCtx.arc(
                            this.x + rand(-10, 10),
                            this.y + rand(-10, 10),
                            rand(2, 6), 0, Math.PI * 2
                        );
                        game.pCtx.fill();
                    }
                }

                if (this.cooldown > 0) this.cooldown--;
            }

            draw(ctx) {
                if (this.dead) return;

                // Draw Character (Spray Can Top look)
                ctx.save();
                ctx.translate(this.x, this.y);

                // Glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;

                // Core
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Inner Color
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.7, 0, Math.PI * 2);
                ctx.fill();

                // Name
                ctx.shadowBlur = 0;
                ctx.fillStyle = "#fff";
                ctx.font = "bold 14px 'Audiowide', sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.name, 0, -this.radius - 15);

                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = rand(2, 8);
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.size = rand(2, 6);
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.03;
                this.size *= 0.95;
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // Init
        new Game();
    </script>
</body>

</html>