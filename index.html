<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPOK ROYALE</title>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Rubik+Glitch&display=swap" rel="stylesheet">
    <!-- p5.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --concrete: #2a2a2a;
            --accent: #FF0055;
            --neon-blue: #00F3FF;
            --neon-green: #00FF66;
            --ui-font: 'Audiowide', cursive;
            --title-font: 'Rubik Glitch', system-ui;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
        }

        body {
            background-color: var(--bg-color);
            color: white;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            font-family: var(--ui-font);
        }

        /* 
           LAYER SYSTEM:
           Z-0: Concrete Texture (CSS/Image)
           Z-2: Game Canvas (Managed by p5, set to Z-2)
           Z-10: UI Layer
        */

        #texture-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background-color: var(--concrete);
            background-image:
                radial-gradient(transparent 0%, #111 100%),
                url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
        }

        /* p5 Canvas Style */
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            /* Let clicks pass through usually */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Setup Panel */
        .panel {
            pointer-events: auto;
            background: rgba(20, 20, 20, 0.9);
            border: 4px solid #fff;
            box-shadow: 10px 10px 0px rgba(0, 0, 0, 0.5);
            padding: 2.5rem;
            width: 90%;
            max-width: 600px;
            text-align: center;
            transform: rotate(-1deg);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .panel h1 {
            font-family: var(--title-font);
            font-size: 4rem;
            margin-bottom: 0.5rem;
            color: white;
            text-shadow: 4px 4px 0px var(--accent);
            line-height: 1;
            transform: scale(1.1);
        }

        .panel p {
            font-family: var(--ui-font);
            color: #888;
            margin-bottom: 2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 0.8rem;
        }

        textarea {
            width: 100%;
            height: 180px;
            background: #000;
            border: 2px solid #333;
            color: var(--neon-green);
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 1.1rem;
            padding: 1rem;
            margin-bottom: 2rem;
            resize: none;
            outline: none;
        }

        textarea:focus {
            border-color: var(--neon-blue);
        }

        .btn {
            background: #fff;
            color: #000;
            border: none;
            padding: 1rem 3rem;
            font-family: var(--ui-font);
            font-size: 1.5rem;
            font-weight: 900;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 5px 5px 0px var(--accent);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn:hover {
            transform: translate(-2px, -2px);
            box-shadow: 7px 7px 0px var(--accent);
            background: var(--neon-blue);
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: 1px 1px 0px var(--accent);
        }

        /* HUD */
        #hud-top {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 2rem;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s;
            z-index: 20;
        }

        #phase-indicator {
            position: absolute;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            text-shadow: 0 0 10px var(--accent);
            z-index: 25;
            display: none;
        }

        .counter {
            background: #000;
            color: #fff;
            padding: 0.5rem 1.5rem;
            font-size: 1.5rem;
            border: 2px solid white;
            box-shadow: 4px 4px 0px var(--neon-blue);
            transform: skew(-10deg);
            display: flex;
            align-items: center;
            justify-content: center;
            height: fit-content;
        }

        .kill-feed {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-end;
        }

        .kill-msg {
            background: #000;
            color: #fff;
            padding: 0.5rem 1rem;
            border-left: 5px solid;
            font-size: 1rem;
            font-family: monospace;
            text-transform: uppercase;
            animation: slideIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* Win Screen */
        #win-overlay {
            opacity: 0;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            transition: opacity 0.5s;
        }

        #win-title {
            font-family: var(--title-font);
            font-size: 8rem;
            line-height: 1;
            margin-bottom: 2rem;
            color: white;
            text-shadow: 10px 10px 0px var(--neon-green);
            transform: rotate(-5deg);
        }

        .hidden {
            display: none !important;
        }

        .visible {
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        @keyframes slideIn {
            from {
                transform: translateX(50px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Debug HUD */
        #debug-hud {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #00FF66;
            padding: 1.5rem;
            z-index: 30;
            font-family: 'Courier New', monospace;
            min-width: 250px;
            max-width: 400px;
            display: none;
            box-shadow: 0 0 20px rgba(0, 255, 102, 0.5);
            max-height: 90vh;
            overflow-y: auto;
        }

        #debug-hud.visible {
            display: block;
        }

        #debug-hud h3 {
            color: #00FF66;
            margin: 0 0 1rem 0;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-align: center;
        }

        .debug-section {
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #333;
        }

        .debug-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .debug-label {
            color: #888;
            font-size: 0.7rem;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
        }

        .debug-btn {
            background: #00FF66;
            color: #000;
            border: none;
            padding: 0.5rem 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            width: 100%;
            margin-bottom: 0.5rem;
            transition: all 0.1s;
        }

        .debug-btn:hover {
            background: #00F3FF;
            transform: translateX(-2px);
        }

        .debug-btn:active {
            transform: translateX(2px);
        }

        .debug-btn.active {
            background: #FF0055;
            color: #fff;
        }

        .speed-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .speed-controls .debug-btn {
            padding: 0.4rem;
            font-size: 0.7rem;
            margin-bottom: 0;
        }

        .speed-display {
            text-align: center;
            color: #00FF66;
            font-size: 1.2rem;
            margin-top: 0.5rem;
            font-weight: bold;
        }

        /* Debug Log */
        #debug-log {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #333;
            padding: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.65rem;
            color: #00FF66;
            margin-top: 0.5rem;
        }

        .log-entry {
            margin-bottom: 0.25rem;
            padding: 0.25rem;
            border-left: 2px solid #00FF66;
            padding-left: 0.5rem;
            line-height: 1.2;
        }

        .log-entry.combat {
            border-left-color: #FF0055;
            color: #FF0055;
        }

        .log-entry.kill {
            border-left-color: #FF6600;
            color: #FF6600;
        }

        .log-entry.ability {
            border-left-color: #00F3FF;
            color: #00F3FF;
        }

        .log-entry.system {
            border-left-color: #FFD700;
            color: #FFD700;
        }

        .log-time {
            color: #666;
            font-size: 0.6rem;
            margin-right: 0.25rem;
        }

        .debug-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 255, 102, 0.1);
            border: 1px solid #00FF66;
            padding: 0.5rem 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.7rem;
            color: #00FF66;
            z-index: 25;
            opacity: 0.5;
            transition: opacity 0.3s;
        }

        .debug-hint:hover {
            opacity: 1;
        }

        /* Role Passive Indicators */
        .role-passive {
            position: absolute;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 15;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 0.9;
            }

            50% {
                transform: scale(1.1);
                opacity: 1;
            }
        }

        .passive-tooltip {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s;
            color: #fff;
        }

        .role-passive:hover .passive-tooltip {
            opacity: 1;
        }

        /* Persistent Action Log HUD */
        #action-log-hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
            max-height: 250px;
            z-index: 20;
            pointer-events: none;
            display: flex;
            flex-direction: column-reverse;
            gap: 4px;
            font-family: 'Courier New', monospace;
        }

        .hud-log-entry {
            background: rgba(0, 0, 0, 0.6);
            border-left: 3px solid #00FF66;
            padding: 4px 8px;
            font-size: 0.75rem;
            color: #fff;
            animation: slideInLeft 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-shadow: 1px 1px 2px #000;
        }

        .hud-log-entry.combat {
            border-left-color: #FF0055;
        }

        .hud-log-entry.kill {
            border-left-color: #FF6600;
        }

        .hud-log-entry.capacit√© {
            border-left-color: #00F3FF;
        }

        .hud-log-entry.syst√®me {
            border-left-color: #FFD700;
        }

        @keyframes slideInLeft {
            from {
                transform: translateX(-20px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Explanation Overlay */
        #explanation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 100;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            overflow-y: auto;
        }

        #explanation-overlay.visible {
            display: flex;
        }

        .explanation-content {
            background: var(--concrete);
            border: 4px solid var(--accent);
            padding: 2rem;
            max-width: 900px;
            width: 100%;
            box-shadow: 10px 10px 0px var(--accent);
            position: relative;
        }

        .explanation-title {
            font-family: 'Rubik Glitch', cursive;
            font-size: 3rem;
            color: var(--neon-blue);
            text-align: center;
            margin-bottom: 1rem;
            text-shadow: 3px 3px 0px var(--accent);
        }

        .explanation-subtitle {
            font-family: var(--ui-font);
            font-size: 1.2rem;
            color: #fff;
            text-align: center;
            margin-bottom: 2rem;
            text-transform: uppercase;
        }

        .roles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .role-card {
            background: #1a1a1a;
            border: 2px solid #333;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            transition: transform 0.2s;
        }

        .role-card:hover {
            transform: translateY(-5px);
            border-color: var(--accent);
        }

        .role-card-emoji {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        .role-card-name {
            font-family: var(--ui-font);
            color: var(--neon-green);
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        .role-card-desc {
            font-size: 0.85rem;
            color: #ccc;
            line-height: 1.4;
            margin-bottom: 0.5rem;
        }

        .role-card-player {
            font-family: var(--ui-font);
            font-size: 0.9rem;
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: bold;
        }

        .explanation-btn-container {
            display: flex;
            justify-content: center;
            margin-top: 1rem;
        }
    </style>
</head>

<body>

    <div id="texture-layer"></div>
    <!-- p5.js will inject the canvas here -->

    <div id="ui-layer">
        <!-- SETUP -->
        <div id="setup-panel" class="panel">
            <h1>EPOK<br>ROYALE</h1>
            <p>Qui laissera sa trace ?</p>
            <textarea id="name-input" spellcheck="false">GHOST
BLADE
NEON
VIPER
SHADE</textarea>
            <div style="margin-bottom: 2rem; display: flex; gap: 1rem; justify-content: center;">
                <button class="btn" id="start-btn">JOUER</button>
                <button class="btn" id="import-btn" title="Importer CSV"
                    style="background: #222; color: #fff; padding: 1rem; aspect-ratio: 1/1; display: flex; align-items: center; justify-content: center; box-shadow: 5px 5px 0px #444;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </button>
            </div>
            <input type="file" id="csv-input" accept=".csv, .txt" style="display: none;" multiple>
        </div>

        <!-- WIN -->
        <div id="win-overlay" class="panel visible hidden"
            style="background: transparent; border: none; box-shadow: none;">
            <div id="win-title">GAGNANT</div>
            <button class="btn" id="restart-btn">REJOUER</button>
        </div>
    </div>

    <div id="hud-top">
        <div class="counter" id="alive-cnt">5 RESTANTS</div>
        <div id="phase-indicator">ECHAUFFEMENT</div>
        <div class="kill-feed" id="kill-feed"></div>
    </div>

    <!-- HUD Action Log -->
    <div id="action-log-hud"></div>

    <!-- Explanation Overlay -->
    <div id="explanation-overlay" style="box-sizing: border-box;">
        <div class="explanation-content" style="box-sizing: border-box;">
            <h2 class="explanation-title">L'AR√àNE SUPR√äME</h2>
            <div class="explanation-subtitle">8 Champions ‚Ä¢ 1 Survivant ‚Ä¢ Quel sera votre destin ?</div>

            <div id="roles-display" class="roles-grid">
                <!-- Roles populated dynamically in transitionToPhase2 -->
            </div>

            <div class="explanation-btn-container">
                <button id="start-phase2-btn" class="btn">COMMENCER LE COMBAT</button>
            </div>
        </div>
    </div>

    <!-- Debug HUD -->
    <div id="debug-hud">
        <h3>‚öôÔ∏è PANEL</h3>

        <div class="debug-section">
            <div class="debug-label">Contr√¥le du Jeu</div>
            <button class="debug-btn" id="debug-pause">Pause</button>
            <button class="debug-btn" id="debug-skip-phase2">Passer √† la Phase 2</button>
            <button class="debug-btn" id="debug-clear-canvas">Effacer le Canevas</button>
            <div
                style="margin-top: 1rem; display: flex; align-items: center; gap: 0.5rem; color: #fff; font-family: monospace; font-size: 0.8rem;">
                <input type="checkbox" id="debug-toggle-trails" style="cursor: pointer;">
                <label for="debug-toggle-trails" style="cursor: pointer;">Afficher les tra√Æn√©es</label>
            </div>
        </div>

        <div class="debug-section">
            <div class="debug-label">Vitesse du Temps</div>
            <div class="speed-controls">
                <button class="debug-btn" id="debug-speed-025">0.25x</button>
                <button class="debug-btn" id="debug-speed-05">0.5x</button>
                <button class="debug-btn active" id="debug-speed-1">1x</button>
                <button class="debug-btn" id="debug-speed-2">2x</button>
                <button class="debug-btn" id="debug-speed-4">4x</button>
                <button class="debug-btn" id="debug-speed-8">8x</button>
            </div>
            <div class="speed-display" id="speed-display">1.00x</div>
        </div>

        <div class="debug-section" style="display: none;">
            <div class="debug-label">Journal d'Action</div>
            <div id="debug-log"></div>
        </div>
    </div>

    <div class="debug-hint">Appuyez sur 'D' pour le Menu de Debug</div>

    <script>
        const CONFIG = {
            minSpeed: 3,
            maxSpeed: 7,
            drag: 1.0,
            radius: 20,
            colors: ['#FF0055', '#00F3FF', '#39FF14', '#FFFF00', '#BE00FF', '#FF6600'],
            crews: {
                cyan: '#00F3FF',
                magenta: '#FF1493'
            },
            traitorGold: '#FFD700',
            showTrails: false
        };

        const ROLES = {
            ninja: { color: '#0066FF', emoji: 'ü•∑', name: 'Ninja', desc: 'Peut changer de place avec l\'adversaire le plus proche.' },
            webmaster: { color: '#E0E0E0', emoji: 'üï∏Ô∏è', name: 'Ma√Ætre-Toile', desc: 'Laisse une tra√Æn√©e de toile qui ralentit les ennemis.' },
            tank: { color: '#888888', emoji: 'üõ°Ô∏è', name: 'Tank', desc: 'Dispose d\'un bouclier directionnel en 3 parties qui repousse les ennemis.' },
            assassin: { color: '#FF0055', emoji: 'üó°Ô∏è', name: 'Assassin', desc: '80% de chance de victoire initiale, mais s\'affaiblit apr√®s chaque combat.' },
            vampire: { color: '#8B00FF', emoji: 'ü¶á', name: 'Vampire', desc: 'Draine la vie des ennemis proches via une aura de sang.' },
            martyr: { color: '#FF6600', emoji: 'üí£', name: 'Martyre', desc: 'Explose √† sa mort, √©liminant les ennemis dans la zone.' },
            glitch: { color: '#00F3FF', emoji: 'üëæ', name: 'Anomalie', desc: 'Se t√©l√©porte al√©atoirement dans l\'ar√®ne.' },
            ghost: { color: '#FFFFFF', emoji: 'üëª', name: 'Fant√¥me', desc: 'Devient intangible et invincible p√©riodiquement.' }
        };

        const APEX_CONFIG = {
            ninjaSwapCooldown: 180,
            ninjaSwapRange: 60,
            glitchTeleportInterval: 240,
            ghostInvincibleTime: 120,
            ghostInvincibleCooldown: 300,
            webLifetime: 4000,
            vampireAuraRadius: 150,
            vampireDrainRate: 0.01,
            vampireRecoverRate: 0.002,
            stalemateTime: 10000,
            shrinkRate: 25
        };

        let game;
        let paintLayer;

        // p5.js Setup
        function setup() {
            let cnv = createCanvas(windowWidth, windowHeight);
            cnv.style('z-index', '2'); // Place above texture, below UI
            cnv.style('position', 'absolute');
            cnv.style('top', '0');
            cnv.style('left', '0');

            // Paint layer as off-screen graphics
            paintLayer = createGraphics(windowWidth, windowHeight);
            paintLayer.clear(); // Make transparent

            game = new Game();

            // Buttons
            select('#start-btn').mousePressed(() => game.start());
            select('#restart-btn').mousePressed(() => game.reset());
            select('#import-btn').mousePressed(() => select('#csv-input').elt.click());
            select('#csv-input').changed((e) => game.handleFileUpload(e));
            select('#start-phase2-btn').mousePressed(() => game.startPhase2());

            // Debug Controls
            game.setupDebugControls();

            frameRate(60);
        }

        // p5.js Draw Loop
        function draw() {
            clear(); // Clear main canvas each frame

            // Draw Persistent Paint Layer
            image(paintLayer, 0, 0);

            if (game) {
                game.update();
                game.draw();
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            // Recreating paintLayer clears it, which might be undesirable, but resizing is complex. 
            // We'll just recreate for now or keep it fixed. 
            // Let's try to preserve it?
            let oldPaint = paintLayer;
            paintLayer = createGraphics(windowWidth, windowHeight);
            paintLayer.image(oldPaint, 0, 0);
            if (game) game.resize(windowWidth, windowHeight);
        }

        class Game {
            constructor() {
                this.width = windowWidth;
                this.height = windowHeight;
                this.players = [];
                this.particles = [];
                this.running = false;
                this.gracePeriod = 0;
                this.gameState = 'TEAMS';

                this.slowMotion = false;
                this.slowMotionFactor = 0.3;
                this.slowMotionDelay = 0;
                this.playerDistances = new Map();

                this.arenaCenter = createVector(0, 0);
                this.arenaRadius = 0;
                this.lastEliminationTime = 0;
                this.webTrails = [];
                this.deathOrderCounter = 0;

                // Debug controls
                this.paused = false;
                this.timeSpeed = 1.0;
                this.debugLog = [];
            }

            log(message, type = 'syst√®me') {
                const timestamp = Math.floor(millis() / 1000);
                const entry = { message, type, timestamp };
                this.debugLog.push(entry);

                // Update log display if debug is visible
                const logEl = select('#debug-log');
                if (logEl && select('#debug-hud').hasClass('visible')) {
                    const logEntry = createDiv('');
                    logEntry.class(`log-entry ${type}`);
                    logEntry.html(`<span class="log-time">[${timestamp}s]</span>${message}`);
                    logEntry.parent('debug-log');
                    logEl.elt.insertBefore(logEntry.elt, logEl.elt.firstChild);

                    // Limit to 50 entries
                    while (logEl.elt.children.length > 50) {
                        logEl.elt.removeChild(logEl.elt.lastChild);
                    }
                }

                // Update HUD log (always visible, last 10)
                const hudLogEl = select('#action-log-hud');
                if (hudLogEl) {
                    const hudEntry = createDiv('');
                    hudEntry.class(`hud-log-entry ${type}`);
                    hudEntry.html(`${message}`);
                    hudEntry.parent('action-log-hud');

                    // Limit to 10 entries in HUD
                    while (hudLogEl.elt.children.length > 10) {
                        hudLogEl.elt.removeChild(hudLogEl.elt.firstChild);
                    }
                }
            }

            resize(w, h) {
                this.width = w;
                this.height = h;
            }

            reset() {
                this.running = false;
                select('#setup-panel').removeClass('hidden');
                select('#win-overlay').addClass('hidden');
                select('#hud-top').removeClass('visible');
                select('#phase-indicator').style('display', 'none');

                paintLayer.clear();
                select('#kill-feed').html('');
            }

            start() {
                const input = select('#name-input').value();
                const playerEntries = input.split('\n').filter(n => n.trim().length > 0);
                if (playerEntries.length < 2) {
                    alert("BESOIN DE PLUS DE JOUEURS");
                    return;
                }

                this.players = [];
                this.gameState = 'TEAMS';
                this.webTrails = [];

                const shuffledEntries = shuffle(playerEntries);
                const mid = ceil(shuffledEntries.length / 2);

                shuffledEntries.forEach((entry, index) => {
                    const team = index < mid ? 'cyan' : 'magenta';
                    let id, name;
                    const parts = entry.split(',').map(p => p.trim());
                    if (parts.length === 2) {
                        id = parts[0];
                        name = parts[1];
                    } else {
                        id = `P${index + 1}`;
                        name = parts[0];
                    }

                    const pos = this.getSafeSpawnPosition(this.players);
                    let x, y;
                    if (pos) { x = pos.x; y = pos.y; }
                    else { x = random(100, this.width - 100); y = random(100, this.height - 100); }

                    this.players.push(new Player(id, name, x, y, team));
                });

                select('#setup-panel').addClass('hidden');
                select('#hud-top').addClass('visible');
                this.updateCount();

                this.gracePeriod = 300;
                this.updatePhaseUI();
                this.running = true;
            }

            update() {
                if (!this.running || this.paused) return;

                if (this.gracePeriod > 0) {
                    this.gracePeriod--;
                    if (this.gracePeriod === 0) this.updatePhaseUI();
                }

                this.updateSlowMotion();

                // Physics steps with time speed multiplier
                const speedMultiplier = (this.slowMotion ? this.slowMotionFactor : 1.0) * this.timeSpeed;

                this.players.forEach(p => p.update(this, speedMultiplier));
                this.checkCollisions();

                if (this.gameState === 'APEX') {
                    this.updateArenaShrinking();
                    this.updateApexMechanics();
                }

                // Update particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    let p = this.particles[i];
                    p.update();
                    if (p.life <= 0) this.particles.splice(i, 1);
                }
            }

            draw() {
                if (this.gameState === 'APEX') {
                    this.drawCircularArena();
                    this.drawWebTrails();
                    this.drawVampireEffects();
                }

                this.players.forEach(p => p.draw());

                // Draw particles
                push();
                blendMode(LIGHTEST); // 'lighter' in standard canvas
                this.particles.forEach(p => p.draw());
                pop();
            }

            // ... Helper Methods ...

            getSafeSpawnPosition(existingPlayers) {
                const buffer = 50;
                for (let i = 0; i < 100; i++) {
                    let x = random(100, this.width - 100);
                    let y = random(100, this.height - 100);
                    let valid = true;
                    let pos = createVector(x, y);
                    for (let p of existingPlayers) {
                        if (p.pos.dist(pos) < (CONFIG.radius * 2) + buffer) {
                            valid = false;
                            break;
                        }
                    }
                    if (valid) return { x, y };
                }
                return null;
            }

            updateCount() {
                const alive = this.players.filter(p => !p.dead).length;
                select('#alive-cnt').html(`${alive} RESTANTS`);
            }

            updatePhaseUI() {
                const el = select('#phase-indicator');
                if (this.gracePeriod > 0) {
                    el.html("PREPAREZ VOUS !");
                    el.style('color', CONFIG.colors[2]);
                    el.style('display', 'block');
                } else {
                    el.html("COMBAT");
                    el.style('color', CONFIG.colors[0]);
                    setTimeout(() => el.style('display', 'none'), 1000);
                }
            }

            logKill(winner, loser, msg = 'A ECLATE') {
                const div = createDiv('');
                div.class('kill-msg');
                div.style('border-color', winner.color);
                div.html(`<span style="color:${winner.color}">${winner.name}</span> ${msg} <span style="color:#888">${loser.name}</span>`);
                div.parent('kill-feed');
                // Prepend logic manual in vanilla JS? p5 'parent' appends to end?
                // p5 DOM doesn't have prepend cleanly without elt access.
                const feed = select('#kill-feed');
                feed.elt.insertBefore(div.elt, feed.elt.firstChild);
                setTimeout(() => div.remove(), 4000);
            }

            updateSlowMotion() {
                const active = this.players.filter(p => !p.dead);
                if (active.length >= 10 || this.gracePeriod > 0 || this.gameState === 'TRANSITION') {
                    this.slowMotion = false;
                    this.playerDistances.clear();
                    return;
                }

                let shouldSlowDown = false;
                const dangerThreshold = this.gameState === 'TEAMS' ? 60 : 100;

                for (let i = 0; i < active.length; i++) {
                    for (let j = i + 1; j < active.length; j++) {
                        const p1 = active[i];
                        const p2 = active[j];
                        if (this.gameState === 'TEAMS' && p1.team === p2.team) continue;

                        const dist = p1.pos.dist(p2.pos);
                        const pairId = `${p1.id}_${p2.id}`;
                        const prevDist = this.playerDistances.get(pairId);
                        this.playerDistances.set(pairId, dist);

                        if (dist < dangerThreshold && prevDist !== undefined && dist < prevDist) {
                            shouldSlowDown = true;
                        }
                    }
                }

                if (shouldSlowDown) {
                    this.slowMotion = true;
                    this.slowMotionDelay = 30;
                } else if (this.slowMotion) {
                    this.slowMotionDelay--;
                    if (this.slowMotionDelay <= 0) this.slowMotion = false;
                }
            }

            checkCollisions() {
                const active = this.players.filter(p => !p.dead);
                for (let i = 0; i < active.length; i++) {
                    for (let j = i + 1; j < active.length; j++) {
                        const p1 = active[i];
                        const p2 = active[j];

                        const dist = p1.pos.dist(p2.pos);

                        // Check for shield collision first (only in APEX mode)
                        if (this.gameState === 'APEX') {
                            // Check if p1 has shield and p2 hits it
                            if (p1.lives > 1 && p1.role === 'tank') {
                                const shieldRadius = p1.radius * 2.5;
                                if (dist < shieldRadius + p2.radius && dist >= p1.radius + p2.radius) {
                                    let arcIndex = this.getShieldArcIndex(p1, p2);
                                    if (p1.shieldArcs[arcIndex]) {
                                        this.handleShieldHit(p1, p2, arcIndex);
                                        continue;
                                    }
                                }
                            }
                            // Check if p2 has shield and p1 hits it
                            if (p2.lives > 1 && p2.role === 'tank') {
                                const shieldRadius = p2.radius * 2.5;
                                if (dist < shieldRadius + p1.radius && dist >= p2.radius + p1.radius) {
                                    let arcIndex = this.getShieldArcIndex(p2, p1);
                                    if (p2.shieldArcs[arcIndex]) {
                                        this.handleShieldHit(p2, p1, arcIndex);
                                        continue;
                                    }
                                }
                            }
                        }

                        // Regular collision detection
                        if (dist < p1.radius + p2.radius) {
                            if (this.gracePeriod > 0) {
                                this.resolveElastic(p1, p2);
                            } else {
                                if (this.gameState === 'TEAMS') {
                                    if (p1.team === p2.team) this.resolveElastic(p1, p2);
                                    else if (p1.cooldown <= 0 && p2.cooldown <= 0) this.resolveCombat(p1, p2);
                                } else if (this.gameState === 'APEX') {
                                    if (p1.cooldown <= 0 && p2.cooldown <= 0) this.resolveApexCombat(p1, p2);
                                }
                            }
                        }
                    }
                }
            }

            resolveElastic(p1, p2) {
                // Vector Physics Intermission
                let dist = p1.pos.dist(p2.pos);
                let overlap = (p1.radius + p2.radius - dist) / 2;
                let n = p5.Vector.sub(p1.pos, p2.pos).normalize();

                // Separate
                p1.pos.add(p5.Vector.mult(n, overlap));
                p2.pos.sub(p5.Vector.mult(n, overlap));

                // Bounce
                // Simple elastic collision logic for equal mass
                let v1n = p1.vel.dot(n);
                let v2n = p2.vel.dot(n);

                if (v1n - v2n > 0) return; // Moving apart

                // Swap normal components (perfect elastic equal mass)
                let v1nTag = v2n; // Tangential remains same, Normal swaps? 
                // Wait, simpler: calculate impulse
                // Impulse J = -(1+e)(vRel . n) / (1/m1 + 1/m2)
                // m1=m2=1 => J = -2(vRel . n) / 2 = -(vRel . n)

                let vRel = p5.Vector.sub(p1.vel, p2.vel);
                let j = -vRel.dot(n);
                let impulse = p5.Vector.mult(n, j);

                p1.vel.add(impulse);
                p2.vel.sub(impulse);
            }

            resolveCombat(p1, p2) {
                const winner = random() > 0.5 ? p1 : p2;
                const loser = winner === p1 ? p2 : p1;
                this.log(`${winner.name} a combattu ${loser.name}`, 'combat');
                this.kill(winner, loser);
            }

            getShieldArcIndex(tank, attacker) {
                let angle = atan2(attacker.pos.y - tank.pos.y, attacker.pos.x - tank.pos.x);
                // Adjust for rotation and normalize to [0, TWO_PI)
                let relativeAngle = (angle - tank.shieldRotation) % TWO_PI;
                if (relativeAngle < 0) relativeAngle += TWO_PI;

                let angleStep = TWO_PI / 3;
                return floor(relativeAngle / angleStep);
            }

            handleShieldHit(tank, attacker, arcIndex) {
                if (arcIndex !== undefined && tank.shieldArcs && !tank.shieldArcs[arcIndex]) return;

                // Bounce attacker away strongly
                let dir = p5.Vector.sub(attacker.pos, tank.pos).normalize();
                attacker.vel = dir.mult(12); // Strong bounce back

                // Destroy specific shield arc
                if (arcIndex !== undefined && tank.shieldArcs) {
                    tank.shieldArcs[arcIndex] = false;
                }

                // Set cooldowns
                tank.cooldown = 30;
                attacker.cooldown = 30;

                // Shield Break Effect
                this.spawnParticles(tank.pos.x, tank.pos.y, '#FFFFFF', 20);

                // Log the shield hit
                const remainingArcs = tank.shieldArcs.filter(a => a).length;
                if (remainingArcs > 0) {
                    this.log(`üõ°Ô∏è ${attacker.name} a rebondi sur un segment du bouclier de ${tank.name} ! (${remainingArcs} segments restants)`, 'capacit√©');
                } else {
                    this.log(`üõ°Ô∏è Dernier bouclier de ${tank.name} d√©truit par ${attacker.name} !`, 'capacit√©');
                }
            }

            kill(winner, loser, msg = 'ECLATE') {
                if (loser.lives > 1) {
                    loser.lives--;
                    loser.cooldown = 30;
                    winner.cooldown = 20;

                    // Bounce Winner away (Loser Tank stays put or bounces less)
                    let dir = p5.Vector.sub(winner.pos, loser.pos).normalize();
                    winner.vel = dir.copy().mult(8);

                    // Shield Break Effect
                    this.spawnParticles(loser.pos.x, loser.pos.y, '#FFFFFF', 15);

                    this.log(`üõ°Ô∏è Bouclier de ${loser.name} touch√© ! (${loser.lives - 1} restants)`, 'capacit√©');
                    return;
                }

                loser.dead = true;
                loser.deathOrder = ++this.deathOrderCounter;

                this.drawSplat(loser.pos.x, loser.pos.y, loser.color, 80, 50);
                this.spawnParticles(loser.pos.x, loser.pos.y, loser.color, 30);

                winner.radius += 5;
                winner.cooldown = 20;

                // Bounce Winner away
                let dir = p5.Vector.sub(winner.pos, loser.pos).normalize();
                winner.vel = dir.mult(8);

                this.log(`üíÄ ${winner.name} a √©limin√© ${loser.name}`, 'kill');
                this.logKill(winner, loser, msg);

                if (loser.role === 'martyr') {
                    this.log(`üí£ ${loser.name} va exploser !`, 'capacit√©');
                }

                this.updateCount();
                this.checkWin();
            }

            checkWin() {
                const active = this.players.filter(p => !p.dead);
                if (this.gameState === 'TEAMS') {
                    const teams = new Set(active.map(p => p.team));
                    if (teams.size === 1) this.transitionToPhase2();
                } else if (this.gameState === 'APEX' && active.length === 1) {
                    this.endGame(active[0]);
                }
            }

            drawSplat(x, y, color, size, count) {
                paintLayer.noStroke();
                paintLayer.fill(color);
                paintLayer.circle(x, y, size * 0.4);
                for (let i = 0; i < count; i++) {
                    let r = random(size * 0.2);
                    let angle = random(TWO_PI);
                    let dist = random(size);
                    paintLayer.circle(x + cos(angle) * dist, y + sin(angle) * dist, r);
                }
            }

            spawnParticles(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }

            async handleFileUpload(e) {
                const fileInput = select('#csv-input').elt;
                const files = Array.from(fileInput.files);
                if (files.length === 0) return;

                const allPlayerEntries = [];

                for (const file of files) {
                    const text = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (event) => resolve(event.target.result);
                        reader.onerror = (error) => reject(error);
                        reader.readAsText(file);
                    });

                    const lines = text.split('\n').filter(line => line.trim().length > 0);
                    if (lines.length < 2) continue;

                    // Parse header to find column indices
                    const header = lines[0].split(',').map(col => col.replace(/"/g, '').trim());
                    const orderIdIndex = header.indexOf('Order ID');
                    const billingNameIndex = header.indexOf('Billing Name');

                    if (orderIdIndex === -1 || billingNameIndex === -1) {
                        console.warn(`Le fichier ${file.name} n'a pas les colonnes requises.`);
                        continue;
                    }

                    // Process each data row (skip header)
                    for (let i = 1; i < lines.length; i++) {
                        const row = this.parseCSVLine(lines[i]);
                        if (row.length <= Math.max(orderIdIndex, billingNameIndex)) continue;

                        let orderId = row[orderIdIndex].replace(/"/g, '').trim();
                        const billingName = row[billingNameIndex].replace(/"/g, '').trim();

                        if (!billingName || !orderId) continue;

                        // Remove leading zeros from order ID
                        orderId = parseInt(orderId, 10).toString();

                        // Parse the name
                        const nameParts = billingName.split(' ').filter(p => p.length > 0);
                        if (nameParts.length === 0) continue;

                        const firstName = nameParts[0];
                        const lastPart = nameParts.length > 1 ? nameParts[nameParts.length - 1] : '';
                        const firstLetter = firstName.charAt(0).toUpperCase();

                        const displayName = firstName;
                        const formattedEntry = `${displayName} ${firstLetter}#${orderId}`;

                        allPlayerEntries.push(formattedEntry);
                    }
                }

                if (allPlayerEntries.length === 0) {
                    alert('Aucune entr√©e de joueur valide trouv√©e dans les fichiers s√©lectionn√©s');
                } else {
                    const currentText = select('#name-input').value();
                    const newText = currentText ? currentText + '\n' + allPlayerEntries.join('\n') : allPlayerEntries.join('\n');
                    select('#name-input').value(newText);
                }

                // Reset file input
                fileInput.value = '';
            }

            parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current);
                return result;
            }

            transitionToPhase2() {
                this.gameState = 'TRANSITION';
                this.paused = true; // Pause physics while explaining

                let top8 = [];
                const survivors = this.players.filter(p => !p.dead);

                // Strategy 1: If we have 8+ alive players, use them
                if (survivors.length >= 8) {
                    // Sort by radius (bigger = stronger)
                    survivors.sort((a, b) => b.radius - a.radius);
                    top8 = survivors.slice(0, 8);
                    // Kill the rest
                    survivors.slice(8).forEach(p => {
                        p.dead = true;
                        this.drawSplat(p.pos.x, p.pos.y, p.color, 60, 30);
                    });
                    this.players.filter(p => p.dead).forEach(p => p.dead = true);
                }
                // Strategy 2: Try to get 8 from winning team (alive + recently dead)
                else if (survivors.length > 0) {
                    const winningTeam = survivors[0].team;
                    const winningTeamPlayers = this.players.filter(p => p.team === winningTeam);

                    winningTeamPlayers.sort((a, b) => {
                        if (!a.dead && b.dead) return -1;
                        if (a.dead && !b.dead) return 1;
                        if (!a.dead) return b.radius - a.radius;
                        return b.deathOrder - a.deathOrder;
                    });

                    top8 = winningTeamPlayers.slice(0, 8);
                    const eliminated = winningTeamPlayers.slice(8);

                    // Revive dead players in top 8
                    top8.forEach(p => {
                        if (p.dead) {
                            p.dead = false;
                            p.radius = CONFIG.radius;
                            this.spawnParticles(p.pos.x, p.pos.y, '#FFFFFF', 20);
                        }
                    });

                    // Kill eliminated from winning team
                    eliminated.forEach(p => {
                        if (!p.dead) {
                            p.dead = true;
                            this.drawSplat(p.pos.x, p.pos.y, p.color, 60, 30);
                        }
                    });

                    // Kill all losing team players
                    this.players.filter(p => p.team !== winningTeam).forEach(p => p.dead = true);
                }
                // Strategy 3: No clear winner, just pick any 8 players (alive first, then recently dead)
                else {
                    const allPlayers = [...this.players];
                    allPlayers.sort((a, b) => {
                        if (!a.dead && b.dead) return -1;
                        if (a.dead && !b.dead) return 1;
                        if (!a.dead) return b.radius - a.radius;
                        return b.deathOrder - a.deathOrder;
                    });

                    top8 = allPlayers.slice(0, 8);

                    // Revive dead players in top 8
                    top8.forEach(p => {
                        if (p.dead) {
                            p.dead = false;
                            p.radius = CONFIG.radius;
                            this.spawnParticles(p.pos.x, p.pos.y, '#FFFFFF', 20);
                        }
                    });

                    // Kill everyone else
                    allPlayers.slice(8).forEach(p => p.dead = true);
                }

                // Assign roles to the top 8
                const roleKeys = shuffle(Object.keys(ROLES));
                top8.forEach((p, idx) => {
                    const key = roleKeys[idx];
                    const role = ROLES[key];
                    p.role = key;
                    p.emoji = role.emoji;
                    p.color = role.color;
                    p.team = null;
                    p.vel = p5.Vector.random2D().mult(random(CONFIG.minSpeed, CONFIG.maxSpeed));

                    if (key === 'ghost') {
                        p.lives = 3;
                        p.ghostInvincible = false;
                        p.ghostInvincibleTimeStep = 0;
                        p.ghostInvincibleCooldown = 60; // Initial delay
                    } else if (key === 'tank') {
                        p.lives = 3;
                        p.shieldArcs = [true, true, true];
                        p.radius = CONFIG.radius * 2;
                    } else {
                        p.lives = 3;
                    }
                    p.ninjaSwapCooldown = 0;
                    p.glitchTeleportCooldown = APEX_CONFIG.glitchTeleportInterval;
                    p.assassinWinChance = 0.8;
                    p.assassinFightsCount = 0;
                });

                console.log('Top 8 players for Phase 2:', top8.map(p => ({ name: p.name, role: p.role })));

                // Clear and populate roles display
                const rolesDisplay = select('#roles-display');
                if (rolesDisplay) {
                    rolesDisplay.html('');
                    top8.forEach(p => {
                        const role = ROLES[p.role];
                        if (role) {
                            const card = createDiv('');
                            card.addClass('role-card');
                            card.html(`
                                <div class="role-card-emoji">${role.emoji}</div>
                                <div class="role-card-name">${role.name.toUpperCase()}</div>
                                <div class="role-card-desc">${role.desc}</div>
                                <div class="role-card-player">${p.name}</div>
                            `);
                            rolesDisplay.child(card);
                        } else {
                            console.error(`Role not found for player ${p.name}: ${p.role}`);
                        }
                    });
                    console.log('Roles display populated');
                } else {
                    console.error('#roles-display not found');
                }

                this.arenaCenter = createVector(this.width / 2, this.height / 2);
                this.arenaRadius = max(this.width, this.height) * 1.2; // Start BIG (Standard BR style)
                this.lastEliminationTime = millis();

                // Show explanation screen IMMEDIATELY
                select('#explanation-overlay').addClass('visible');
            }

            startPhase2() {
                select('#explanation-overlay').removeClass('visible');

                // Start transition/warmup sequence
                const el = select('#phase-indicator');
                el.html("PHASE 2");
                el.style('color', '#FFFFFF');
                el.style('display', 'block');
                el.style('font-size', '5rem');
                el.style('width', '100%');
                el.style('text-align', 'center');

                setTimeout(() => {
                    el.html("L'AR√àNE SUPR√äME");
                    el.style('color', '#FFD700');

                    setTimeout(() => {
                        el.style('display', 'none');
                        this.paused = false;
                        this.gameState = 'APEX';
                        this.updateCount();
                        this.log('‚öîÔ∏è LE COMBAT FINAL COMMENCE !', 'syst√®me');
                    }, 2000);
                }, 2000);
            }

            updateArenaShrinking() {
                // Shrink constantly like a normal BR zone closing in
                // Speed up slightly if it's huge?
                let currentRate = APEX_CONFIG.shrinkRate;
                if (this.arenaRadius > this.height) currentRate *= 2;

                this.arenaRadius = max(80, this.arenaRadius - (currentRate * (deltaTime / 1000)));
            }

            drawCircularArena() {
                const r = this.arenaRadius;
                push();
                noFill();
                strokeWeight(4);
                stroke(255, 255, 255, 230);
                drawingContext.shadowBlur = 15;
                drawingContext.shadowColor = '#FFFFFF';

                // Jagged circle
                beginShape();
                for (let a = 0; a < TWO_PI; a += 0.1) {
                    let off = random(-4, 4);
                    let x = this.arenaCenter.x + cos(a) * (r + off);
                    let y = this.arenaCenter.y + sin(a) * (r + off);
                    vertex(x, y);
                }
                endShape(CLOSE);

                // Shrink warning
                if (millis() - this.lastEliminationTime > APEX_CONFIG.stalemateTime) {
                    stroke(255, 0, 0, 150);
                    setLineDash([10, 10]);
                    circle(this.arenaCenter.x, this.arenaCenter.y, (r - 20) * 2);
                }
                pop();
            }

            updateApexMechanics() {
                // Simplified mechanics port
                const active = this.players.filter(p => !p.dead && p.role);
                active.forEach(p => {
                    if (p.role === 'ninja') {
                        if (p.ninjaSwapCooldown > 0) p.ninjaSwapCooldown--;

                        if (p.ninjaSwapCooldown <= 0) {
                            // Find nearest other active player within range
                            let nearest = null;
                            let minDist = APEX_CONFIG.ninjaSwapRange;

                            active.forEach(other => {
                                if (p === other) return;
                                let d = p.pos.dist(other.pos);
                                if (d < minDist) {
                                    minDist = d;
                                    nearest = other;
                                }
                            });

                            if (nearest) {
                                // Swap positions
                                let tempPos = p.pos.copy();
                                p.pos.set(nearest.pos);
                                nearest.pos.set(tempPos);

                                p.ninjaSwapCooldown = APEX_CONFIG.ninjaSwapCooldown;
                                this.spawnParticles(p.pos.x, p.pos.y, p.color, 15);
                                this.spawnParticles(nearest.pos.x, nearest.pos.y, nearest.color, 15);
                                this.log(`ü•∑ ${p.name} a √©chang√© avec ${nearest.name}`, 'capacit√©');
                            }
                        }
                    }
                    if (p.role === 'glitch') {
                        p.glitchTeleportCooldown--;
                        if (p.glitchTeleportCooldown <= 0) {
                            let angle = random(TWO_PI);
                            let dist = random(this.arenaRadius - 40);
                            p.pos.set(this.arenaCenter.x + cos(angle) * dist, this.arenaCenter.y + sin(angle) * dist);
                            p.glitchTeleportCooldown = APEX_CONFIG.glitchTeleportInterval;
                            this.spawnParticles(p.pos.x, p.pos.y, p.color, 15);
                            this.log(`üëæ ${p.name} s'est t√©l√©port√©`, 'capacit√©');
                        }
                    }
                    if (p.role === 'webmaster') {
                        this.webTrails.push({
                            pos: p.pos.copy(),
                            timestamp: millis(),
                            color: p.color,
                            id: p.id,
                            sourcePlayer: p // Store reference to the webmaster
                        });
                    }
                    if (p.role === 'ghost') {
                        if (p.ghostInvincible) {
                            p.ghostInvincibleTimeStep--;
                            if (p.ghostInvincibleTimeStep <= 0) {
                                p.ghostInvincible = false;
                                p.ghostInvincibleCooldown = APEX_CONFIG.ghostInvincibleCooldown;
                                this.log(`üëª ${p.name} n'est plus invincible`, 'capacit√©');
                            }
                        } else {
                            if (p.ghostInvincibleCooldown > 0) {
                                p.ghostInvincibleCooldown--;
                            } else {
                                p.ghostInvincible = true;
                                p.ghostInvincibleTimeStep = APEX_CONFIG.ghostInvincibleTime;
                                this.log(`üëª ${p.name} devient intangible !`, 'capacit√©');
                                this.spawnParticles(p.pos.x, p.pos.y, '#FFFFFF', 10);
                            }
                        }
                    }
                });

                // Trail cleanup
                this.webTrails = this.webTrails.filter(t => millis() - t.timestamp < APEX_CONFIG.webLifetime);

                // Trail collision (Slow instead of Kill)
                active.forEach(p => {
                    if (p.role === 'webmaster' || p.ghostInvincible) return;
                    for (let t of this.webTrails) {
                        if (t.id !== p.id && p.pos.dist(t.pos) < p.radius) {
                            if (p.webSlowTimer <= 0) {
                                this.log(`üï∏Ô∏è ${p.name} est ralenti par ${t.sourcePlayer.name}`, 'capacit√©');
                            }
                            p.webSlowTimer = 10; // Apply slow
                            p.webSlowSource = t.sourcePlayer; // Track who's slowing us
                            break;
                        }
                    }
                });

                // Vampire Logic & Recover
                active.forEach(victim => {
                    let beingDrained = false;
                    let sourceVampire = null;

                    if (victim.role !== 'vampire' && !victim.ghostInvincible) {
                        for (let p of active) {
                            if (p.role === 'vampire' && p.pos.dist(victim.pos) <= APEX_CONFIG.vampireAuraRadius) {
                                beingDrained = true;
                                sourceVampire = p;
                                break;
                            }
                        }
                    }

                    if (beingDrained) {
                        victim.vampireDrainMeter = min(1.0, victim.vampireDrainMeter + APEX_CONFIG.vampireDrainRate);
                        if (victim.vampireDrainMeter >= 1.0) {
                            this.log(`ü¶á ${sourceVampire.name} a drain√© ${victim.name}`, 'capacit√©');
                            this.kill(sourceVampire, victim, 'DRAINE');
                            victim.vampireDrainMeter = 0; // Reset just in case (though they are dead)
                        }
                    } else {
                        victim.vampireDrainMeter = max(0, victim.vampireDrainMeter - APEX_CONFIG.vampireRecoverRate);
                    }
                });
            }

            drawWebTrails() {
                push();
                noStroke();
                strokeWeight(16);
                noFill();
                strokeCap(ROUND);

                // Draw as connected lines
                if (this.webTrails.length > 1) {
                    for (let i = 0; i < this.webTrails.length - 1; i++) {
                        let t1 = this.webTrails[i];
                        let t2 = this.webTrails[i + 1];

                        // Break line if distance is too big (teleport) or different player
                        if (t1.id !== t2.id || t1.pos.dist(t2.pos) > 100) continue;

                        let age = millis() - t1.timestamp;
                        let alpha = map(age, 0, APEX_CONFIG.webLifetime, 100, 0);

                        let c = color(t1.color);
                        c.setAlpha(alpha);
                        stroke(c);

                        line(t1.pos.x, t1.pos.y, t2.pos.x, t2.pos.y);
                    }
                }
                pop();
                pop();
            }

            drawVampireEffects() {
                const vampires = this.players.filter(p => !p.dead && p.role === 'vampire');
                if (vampires.length === 0) return;

                push();
                vampires.forEach(v => {
                    // Draw Aura
                    noFill();
                    stroke(v.color);
                    strokeWeight(2);
                    drawingContext.setLineDash([5, 5]);

                    // Rotate aura
                    push();
                    translate(v.pos.x, v.pos.y);
                    rotate(millis() / 500);
                    circle(0, 0, APEX_CONFIG.vampireAuraRadius * 2);
                    pop();

                    drawingContext.setLineDash([]);

                    // Draw Drain Lines to close enemies
                    this.players.filter(p => !p.dead && p !== v).forEach(victim => {
                        let d = v.pos.dist(victim.pos);
                        if (d < APEX_CONFIG.vampireAuraRadius) {
                            // Red drain beam
                            stroke(255, 0, 0, 150);
                            strokeWeight(map(d, 0, APEX_CONFIG.vampireAuraRadius, 8, 1));
                            line(v.pos.x, v.pos.y, victim.pos.x, victim.pos.y);

                            // Particles towards vampire
                            fill(255, 0, 0);
                            noStroke();
                            let t = millis() / 100;
                            let count = 3;
                            for (let i = 0; i < count; i++) {
                                let lerpVal = (t + i / count) % 1;
                                let px = lerp(victim.pos.x, v.pos.x, lerpVal);
                                let py = lerp(victim.pos.y, v.pos.y, lerpVal);
                                circle(px, py, 6);
                            }
                        }
                    });
                });
                pop();
            }

            resolveApexCombat(p1, p2) {
                if (p1.ghostInvincible || p2.ghostInvincible) {
                    this.resolveElastic(p1, p2);
                    return;
                }
                // Base 50/50 combat
                let p1Win = 0.5;

                // Assassin logic with degrading win rate
                if (p1.role === 'assassin') {
                    p1Win = p1.assassinWinChance;
                }
                if (p2.role === 'assassin') {
                    p1Win = 1 - p2.assassinWinChance;
                }

                let winner = random() < p1Win ? p1 : p2;
                let loser = winner === p1 ? p2 : p1;

                // Degrade assassin's win chance after each fight
                if (winner.role === 'assassin') {
                    winner.assassinFightsCount++;
                    const oldChance = winner.assassinWinChance;
                    winner.assassinWinChance = max(0.08, 0.8 - (winner.assassinFightsCount * 0.12));
                    this.log(`üó°Ô∏è ${winner.name} assassin d√©grad√© : ${Math.round(oldChance * 100)}% ‚Üí ${Math.round(winner.assassinWinChance * 100)}%`, 'capacit√©');
                    // Visual feedback for degradation
                    this.spawnParticles(winner.pos.x, winner.pos.y, '#FF0055', 8);
                }
                if (loser.role === 'assassin') {
                    loser.assassinFightsCount++;
                    loser.assassinWinChance = max(0.08, 0.8 - (loser.assassinFightsCount * 0.12));
                }

                this.kill(winner, loser, 'A ECLATE'); // Explicitly set duel msg
            }

            endGame(winner) {
                this.running = false;
                setTimeout(() => {
                    select('#win-title').html(winner.name + "<br>GAGNE");
                    select('#win-title').style('text-shadow', `10px 10px 0px ${winner.color}`);
                    select('#win-overlay').removeClass('hidden');
                    select('#win-overlay').addClass('visible');
                }, 1000);
            }

            setupDebugControls() {
                // Toggle debug HUD with 'D' key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'd' || e.key === 'D') {
                        select('#debug-hud').toggleClass('visible');
                    }
                });

                // Pause/Resume
                select('#debug-pause').mousePressed(() => {
                    this.paused = !this.paused;
                    const btn = select('#debug-pause');
                    if (this.paused) {
                        btn.html('Resume');
                        btn.addClass('active');
                    } else {
                        btn.html('Pause');
                        btn.removeClass('active');
                    }
                });

                // Skip to Phase 2
                select('#debug-skip-phase2').mousePressed(() => {
                    if (!this.running) {
                        alert('Commencez le jeu d\'abord !');
                        return;
                    }
                    if (this.gameState !== 'TEAMS') {
                        alert('D√©j√† apr√®s la Phase 1 !');
                        return;
                    }
                    this.log('üéØ PHASE 2 : Le Top 8 avance vers l\'Ar√®ne Supr√™me', 'syst√®me');
                    this.transitionToPhase2();
                });

                // Clear Canvas
                select('#debug-clear-canvas').mousePressed(() => {
                    paintLayer.clear();
                    this.log('üßπ Canevas effac√©', 'syst√®me');
                });

                // Toggle Trails
                const trailToggle = select('#debug-toggle-trails');
                if (trailToggle) {
                    trailToggle.elt.checked = CONFIG.showTrails;
                    trailToggle.changed(() => {
                        CONFIG.showTrails = trailToggle.elt.checked;
                        this.log(`üé® Tra√Æn√©es : ${CONFIG.showTrails ? 'ON' : 'OFF'}`, 'syst√®me');
                    });
                }

                // Speed controls
                const speeds = [
                    { id: 'debug-speed-025', value: 0.25 },
                    { id: 'debug-speed-05', value: 0.5 },
                    { id: 'debug-speed-1', value: 1.0 },
                    { id: 'debug-speed-2', value: 2.0 },
                    { id: 'debug-speed-4', value: 4.0 },
                    { id: 'debug-speed-8', value: 8.0 }
                ];

                speeds.forEach(({ id, value }) => {
                    select(`#${id}`).mousePressed(() => {
                        this.timeSpeed = value;
                        // Update button states
                        speeds.forEach(s => select(`#${s.id}`).removeClass('active'));
                        select(`#${id}`).addClass('active');
                        // Update display
                        select('#speed-display').html(`${value.toFixed(2)}x`);
                    });
                });
            }
        }

        class Player {
            constructor(id, name, x, y, team) {
                this.id = id;
                this.name = name;
                this.pos = createVector(x, y);
                this.vel = p5.Vector.random2D().mult(random(CONFIG.minSpeed, CONFIG.maxSpeed));
                this.radius = CONFIG.radius;
                this.team = team;
                this.color = team ? CONFIG.crews[team] : random(CONFIG.colors);

                this.dead = false;
                this.cooldown = 0;
                this.role = null;
                this.emoji = '';
                this.lives = 1;
                this.ghostInvincible = false;
                this.ghostInvincibleTimeStep = 0;
                this.ghostInvincibleCooldown = 0;
                this.glitchTeleportCooldown = 0;
                this.webSlowTimer = 0;
                this.webSlowSource = null; // Track which player is slowing us
                this.prevPos = this.pos.copy();

                // Assassin degrading win chance
                this.assassinWinChance = 0.8; // Start at 80%
                this.assassinFightsCount = 0;

                this.vampireDrainMeter = 0;
                this.shieldArcs = [true, true, true]; // Each represents a 120 deg arc
                this.shieldRotation = 0;
            }

            update(game, speedMult) {
                if (this.dead) return;

                // Web Slow Effect
                if (this.webSlowTimer > 0) {
                    speedMult *= 0.2;
                    this.webSlowTimer--;
                }

                this.prevPos.set(this.pos); // Store previous position
                this.pos.add(p5.Vector.mult(this.vel, speedMult));

                // Boundary
                // Screen Boundary (Always Active)
                if (this.pos.x < this.radius) { this.pos.x = this.radius; this.vel.x *= -1; }
                if (this.pos.x > width - this.radius) { this.pos.x = width - this.radius; this.vel.x *= -1; }
                if (this.pos.y < this.radius) { this.pos.y = this.radius; this.vel.y *= -1; }
                if (this.pos.y > height - this.radius) { this.pos.y = height - this.radius; this.vel.y *= -1; }

                // Zone Boundary (APEX Mode Only)
                if (game.gameState === 'APEX' && game.arenaRadius > 0) {
                    let center = game.arenaCenter;
                    let dist = this.pos.dist(center);
                    if (dist + this.radius > game.arenaRadius) {
                        let n = p5.Vector.sub(center, this.pos).normalize();
                        let overflow = dist + this.radius - game.arenaRadius;

                        // Push back inside zone
                        this.pos.add(p5.Vector.mult(n, overflow));

                        // Reflect velocity (bounce off zone wall)
                        this.vel.reflect(n);
                    }
                }

                if (this.cooldown > 0) this.cooldown--;

                // Paint trail (Continuous Stroke)
                if (CONFIG.showTrails) {
                    let d = this.prevPos.dist(this.pos);
                    if (d < this.radius * 2) { // Only draw if moved a reasonable distance (prevents teleport streaks)
                        let c = color(this.color);
                        c.setAlpha(60); // Low opacity for spray paint effect

                        paintLayer.stroke(c);
                        paintLayer.strokeWeight(this.radius * 0.8 * 2);
                        paintLayer.strokeCap(ROUND);
                        // Use lines to avoid "dots"
                        paintLayer.line(this.prevPos.x, this.prevPos.y, this.pos.x, this.pos.y);
                    }
                }

                // Occasional drip
                if (CONFIG.showTrails && random() > 0.95) {
                    let c = color(this.color);
                    c.setAlpha(60);
                    paintLayer.noStroke();
                    paintLayer.fill(c);
                    paintLayer.circle(
                        this.pos.x + random(-10, 10),
                        this.pos.y + random(-10, 10),
                        random(2, 6) * 2
                    );
                }
            }

            draw() {
                if (this.dead) return;
                push();
                translate(this.pos.x, this.pos.y);

                if (this.ghostInvincible) {
                    drawingContext.globalAlpha = 0.4;
                    drawingContext.shadowBlur = 40;
                    drawingContext.shadowColor = '#FFFFFF';
                    // Extra ghostly glow circle
                    push();
                    noStroke();
                    fill(255, 255, 255, 50);
                    circle(0, 0, this.radius * 2.5 + sin(frameCount * 0.1) * 5);
                    pop();
                }

                drawingContext.shadowBlur = 20;
                drawingContext.shadowColor = this.color;

                fill(255);
                stroke(0);
                strokeWeight(4); // Thick black border
                circle(0, 0, this.radius * 2);

                fill(this.color);
                circle(0, 0, this.radius * 1.4);

                // Tank Shield Visuals - 3 arcs forming a single circle
                if (this.role === 'tank' && this.lives > 1) {
                    noFill();
                    strokeWeight(6);
                    let shieldRadius = this.radius * 2.5;
                    this.shieldRotation += 0.02; // Constant rotation

                    push();
                    rotate(this.shieldRotation);

                    let angleStep = TWO_PI / 3;
                    for (let i = 0; i < 3; i++) {
                        if (this.shieldArcs[i]) {
                            stroke(255, 255, 255, 200);
                            let startAngle = i * angleStep;
                            let endAngle = startAngle + (angleStep * 0.85); // Small gaps between arcs
                            arc(0, 0, shieldRadius * 2, shieldRadius * 2, startAngle, endAngle);
                        }
                    }
                    pop();
                }

                drawingContext.shadowBlur = 0;
                drawingContext.globalAlpha = 1;

                // Role emoji at the top center (above everything)
                if (this.emoji) {
                    textAlign(CENTER, CENTER);
                    textSize(24);
                    text(this.emoji, 0, -this.radius - 35);
                }

                // Player name
                fill(255);
                textAlign(CENTER, CENTER);
                textSize(14);
                textFont('Audiowide');
                text(this.name, 0, -this.radius - 12);

                // Lives indicators (3 green dots)
                if (game.gameState === 'APEX') {
                    this.drawLivesIndicator();
                }

                // Role passive indicators (drawn around the sides)
                this.drawRolePassives();

                pop();
            }

            drawLivesIndicator() {
                const dotSize = 10;
                const spacing = 12;
                const totalWidth = (3 * dotSize) + (2 * spacing);
                const startX = -totalWidth / 2 + dotSize / 2;
                const yPos = -this.radius - 55; // Above the role emoji if it exists

                for (let i = 0; i < 3; i++) {
                    if (i < this.lives) {
                        fill(0, 255, 102); // Neon Green
                        stroke(0);
                        strokeWeight(1);
                    } else {
                        fill(50); // Gray for lost life
                        noStroke();
                    }
                    circle(startX + i * spacing, yPos, dotSize);
                }
            }

            drawRolePassives() {
                if (!this.role) return;

                const passives = [];

                // Collect active passives based on role
                if (this.role === 'assassin') {
                    const percentage = Math.round(this.assassinWinChance * 100);
                    passives.push({
                        icon: 'üó°Ô∏è',
                        color: '#FF0055',
                        text: '',
                        tooltip: `Chances de victoire : ${percentage}%`,
                        progress: this.assassinWinChance // Add progress value for visual arc
                    });
                }

                if (this.role === 'vampire') {
                    passives.push({
                        icon: 'ü¶á',
                        color: '#8B00FF',
                        text: '',
                        tooltip: 'Aura de Drain de Vie'
                    });
                }

                if (this.role === 'ghost' && this.ghostInvincible) {
                    passives.push({
                        icon: 'üëª',
                        color: '#FFFFFF',
                        text: '',
                        tooltip: 'Invincible'
                    });
                }

                if (this.role === 'ninja') {
                    const cooldownSec = Math.round(this.ninjaSwapCooldown / 60);
                    passives.push({
                        icon: 'ü•∑',
                        color: '#0066FF',
                        text: cooldownSec > 0 ? `${cooldownSec}s` : '‚úì',
                        tooltip: cooldownSec > 0 ? `√âchange dans ${cooldownSec}s` : '√âchange Pr√™t'
                    });
                }

                if (this.vampireDrainMeter > 0) {
                    passives.push({
                        icon: 'ü¶á',
                        color: '#FF0055',
                        text: `${Math.round(this.vampireDrainMeter * 100)}%`,
                        tooltip: `DRAIN : ${Math.round(this.vampireDrainMeter * 100)}%`
                    });
                }

                if (this.role === 'webmaster') {
                    passives.push({
                        icon: 'üï∏Ô∏è',
                        color: '#E0E0E0',
                        text: '',
                        tooltip: 'Laisse des tra√Æn√©es de toile'
                    });
                }

                if (this.role === 'glitch') {
                    const cooldownSec = Math.round(this.glitchTeleportCooldown / 60);
                    passives.push({
                        icon: 'üëæ',
                        color: '#00F3FF',
                        text: cooldownSec > 0 ? `${cooldownSec}s` : '‚úì',
                        tooltip: cooldownSec > 0 ? `T√©l√©portation dans ${cooldownSec}s` : 'T√©l√©portation Pr√™te'
                    });
                }

                if (this.role === 'martyr') {
                    passives.push({
                        icon: 'üí£',
                        color: '#FF6600',
                        text: '',
                        tooltip: 'Explose √† la mort'
                    });
                }

                if (this.webSlowTimer > 0) {
                    const sourceColor = this.webSlowSource ? this.webSlowSource.color : '#E0E0E0';
                    passives.push({
                        icon: 'üï∏Ô∏è',
                        color: sourceColor,
                        text: '!',
                        tooltip: 'Ralenti par la toile'
                    });
                }

                // Draw passive indicators around the player (avoiding the top where emoji is)
                const angleStep = TWO_PI / passives.length;
                const startAngle = passives.length === 1 ? HALF_PI : 0; // If only 1 passive, put it at bottom
                passives.forEach((passive, index) => {
                    const angle = startAngle + (index * angleStep);
                    const distance = this.radius + 28;
                    const px = cos(angle) * distance;
                    const py = sin(angle) * distance;

                    push();
                    translate(px, py);

                    // Passive indicator background
                    fill(0, 0, 0, 200);
                    stroke(passive.color);
                    strokeWeight(2);
                    circle(0, 0, 24);

                    // Draw progress arc if available (for assassin)
                    if (passive.progress !== undefined) {
                        noFill();
                        stroke(passive.color);
                        strokeWeight(3);
                        strokeCap(ROUND);
                        const arcAngle = passive.progress * TWO_PI;
                        // Draw arc from top, going clockwise
                        arc(0, 0, 28, 28, -HALF_PI, -HALF_PI + arcAngle);

                        // Draw dimmed full circle to show total
                        stroke(passive.color + '40'); // Add transparency
                        strokeWeight(1);
                        noFill();
                        circle(0, 0, 28);
                    }

                    // Icon
                    noStroke();
                    textAlign(CENTER, CENTER);
                    textSize(14);
                    text(passive.icon, 0, 0);

                    // Text overlay (e.g., for other abilities)
                    if (passive.text) {
                        fill(255);
                        textSize(8);
                        textFont('Courier New');
                        textStyle(BOLD);
                        text(passive.text, 0, 12);
                    }

                    pop();
                });
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.pos = createVector(x, y);
                this.vel = p5.Vector.random2D().mult(random(2, 8));
                this.color = color;
                this.life = 1.0;
                this.size = random(2, 6);
            }
            update() {
                this.pos.add(this.vel);
                this.life -= 0.03;
                this.size *= 0.95;
            }
            draw() {
                noStroke();
                let c = color(this.color);
                c.setAlpha(this.life * 255);
                fill(c);
                circle(this.pos.x, this.pos.y, this.size * 2);
            }
        }

        function setLineDash(list) {
            drawingContext.setLineDash(list);
        }
    </script>
</body>

</html>