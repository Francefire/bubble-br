<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPOK ROYALE</title>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Audiowide&family=Rubik+Glitch&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #121212;
            --concrete: #2a2a2a;
            --accent: #FF0055;
            --neon-blue: #00F3FF;
            --neon-green: #00FF66;
            --ui-font: 'Audiowide', cursive;
            --title-font: 'Rubik Glitch', system-ui;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            user-select: none;
        }

        body {
            background-color: var(--bg-color);
            color: white;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            font-family: var(--ui-font);
        }

        /* 
           LAYER SYSTEM:
           Z-0: Concrete Texture (CSS/Image)
           Z-1: Paint Canvas (Persistent Splatters)
           Z-2: Game Canvas (Active Players)
           Z-10: UI Layer
        */

        #texture-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            background-color: var(--concrete);
            background-image:
                radial-gradient(transparent 0%, #111 100%),
                url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #paint-canvas {
            z-index: 1;
            filter: contrast(1.2) brightness(1.1);
            /* Make paint pop */
        }

        #game-canvas {
            z-index: 2;
        }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            /* Let clicks pass through usually */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Setup Panel */
        .panel {
            pointer-events: auto;
            background: rgba(20, 20, 20, 0.9);
            border: 4px solid #fff;
            box-shadow: 10px 10px 0px rgba(0, 0, 0, 0.5);
            padding: 2.5rem;
            width: 90%;
            max-width: 600px;
            text-align: center;
            transform: rotate(-1deg);
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .panel h1 {
            font-family: var(--title-font);
            font-size: 4rem;
            margin-bottom: 0.5rem;
            color: white;
            text-shadow: 4px 4px 0px var(--accent);
            line-height: 1;
            transform: scale(1.1);
        }

        .panel p {
            font-family: var(--ui-font);
            color: #888;
            margin-bottom: 2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 0.8rem;
        }

        textarea {
            width: 100%;
            height: 180px;
            background: #000;
            border: 2px solid #333;
            color: var(--neon-green);
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 1.1rem;
            padding: 1rem;
            margin-bottom: 2rem;
            resize: none;
            outline: none;
        }

        textarea:focus {
            border-color: var(--neon-blue);
        }

        .btn {
            background: #fff;
            color: #000;
            border: none;
            padding: 1rem 3rem;
            font-family: var(--ui-font);
            font-size: 1.5rem;
            font-weight: 900;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 5px 5px 0px var(--accent);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .btn:hover {
            transform: translate(-2px, -2px);
            box-shadow: 7px 7px 0px var(--accent);
            background: var(--neon-blue);
        }

        .btn:active {
            transform: translate(2px, 2px);
            box-shadow: 1px 1px 0px var(--accent);
        }

        /* HUD */
        #hud-top {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 2rem;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s;
            z-index: 20;
        }

        #phase-indicator {
            position: absolute;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 2rem;
            text-shadow: 0 0 10px var(--accent);
            z-index: 25;
            display: none;
        }

        .counter {
            background: #000;
            color: #fff;
            padding: 0.5rem 1.5rem;
            font-size: 1.5rem;
            border: 2px solid white;
            box-shadow: 4px 4px 0px var(--neon-blue);
            transform: skew(-10deg);
            display: flex;
            align-items: center;
            justify-content: center;
            height: fit-content;
        }

        .kill-feed {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-end;
        }

        .kill-msg {
            background: #000;
            color: #fff;
            padding: 0.5rem 1rem;
            border-left: 5px solid;
            font-size: 1rem;
            font-family: monospace;
            text-transform: uppercase;
            animation: slideIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* Win Screen */
        #win-overlay {
            opacity: 0;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            transition: opacity 0.5s;
        }

        #win-title {
            font-family: var(--title-font);
            font-size: 8rem;
            line-height: 1;
            margin-bottom: 2rem;
            color: white;
            text-shadow: 10px 10px 0px var(--neon-green);
            transform: rotate(-5deg);
        }

        .hidden {
            display: none !important;
        }

        .visible {
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        @keyframes slideIn {
            from {
                transform: translateX(50px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>

<body>

    <div id="texture-layer"></div>
    <canvas id="paint-canvas"></canvas>
    <canvas id="game-canvas"></canvas>

    <div id="ui-layer">
        <!-- SETUP -->
        <div id="setup-panel" class="panel">
            <h1>EPOK<br>ROYALE</h1>
            <p>Qui laissera sa trace ?</p>
            <textarea id="name-input" spellcheck="false">GHOST
BLADE
NEON
VIPER
SHADE</textarea>
            <div style="margin-bottom: 2rem; display: flex; gap: 1rem; justify-content: center;">
                <button class="btn" id="start-btn">JOUER</button>
                <button class="btn" id="import-btn" title="Importer CSV"
                    style="background: #222; color: #fff; padding: 1rem; aspect-ratio: 1/1; display: flex; align-items: center; justify-content: center; box-shadow: 5px 5px 0px #444;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none"
                        stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </button>
            </div>
            <input type="file" id="csv-input" accept=".csv, .txt" style="display: none;" multiple>
        </div>

        <!-- WIN -->
        <div id="win-overlay" class="panel visible hidden"
            style="background: transparent; border: none; box-shadow: none;">
            <div id="win-title">GAGNANT</div>
            <button class="btn" id="restart-btn">REJOUER</button>
        </div>
    </div>

    <div id="hud-top">
        <div class="counter" id="alive-cnt">5 RESTANTS</div>
        <div id="phase-indicator">WARMUP</div>
        <div class="kill-feed" id="kill-feed"></div>
    </div>

    <script>
        const CONFIG = {
            minSpeed: 3,
            maxSpeed: 7,
            drag: 1.0,
            radius: 20,
            colors: ['#FF0055', '#00F3FF', '#39FF14', '#FFFF00', '#BE00FF', '#FF6600'],
            crews: {
                cyan: '#00F3FF',
                magenta: '#FF1493' // Hot Pink
            },
            traitorGold: '#FFD700'
        };

        // Phase 2: Top 8 Champions Roles Configuration
        const ROLES = {
            ninja: { color: '#0066FF', emoji: 'ðŸ¥·', name: 'Ninja' },
            trailblazer: { color: '#39FF14', emoji: 'â˜£ï¸', name: 'Trailblazer' },
            tank: { color: '#888888', emoji: 'ðŸ›¡ï¸', name: 'Tank' },
            assassin: { color: '#FF0055', emoji: 'ðŸ—¡ï¸', name: 'Assassin' },
            vampire: { color: '#8B00FF', emoji: 'ðŸ¦‡', name: 'Vampire' },
            martyr: { color: '#FF6600', emoji: 'ðŸ’£', name: 'Martyr' },
            glitch: { color: '#00F3FF', emoji: 'ðŸ‘¾', name: 'Glitch' },
            ghost: { color: '#FFFFFF', emoji: 'ðŸ‘»', name: 'Ghost' }
        };

        const APEX_CONFIG = {
            ninjaSwapCooldown: 180,      // 3 seconds at 60fps
            ninjaSwapRange: 60,          // pixels
            glitchTeleportInterval: 240, // 4 seconds at 60fps
            ghostInvincibleTime: 120,    // 2 seconds at 60fps
            trailLifetime: 300,          // 5 seconds at 60fps
            vampireAuraRadius: 100,      // pixels
            vampireDeathChance: 0.005,   // 0.5% per frame
            stalemateTime: 10000,        // 10 seconds in ms
            shrinkRate: 25               // pixels per second
        };

        const $ = id => document.getElementById(id);
        const rand = (min, max) => Math.random() * (max - min) + min;
        const randInt = (min, max) => Math.floor(rand(min, max));
        const randColor = () => CONFIG.colors[randInt(0, CONFIG.colors.length)];

        class Game {
            constructor() {
                this.gameCanvas = $('game-canvas');
                this.paintCanvas = $('paint-canvas');
                this.gCtx = this.gameCanvas.getContext('2d');
                this.pCtx = this.paintCanvas.getContext('2d');

                this.width = window.innerWidth;
                this.height = window.innerHeight;

                this.players = [];
                this.particles = []; // For transient effects like sparks
                this.running = false;
                this.gracePeriod = 0;

                // Slow-motion system for suspense
                this.slowMotion = false;
                this.slowMotionFactor = 0.3; // How slow (0.3 = 30% speed)
                this.slowMotionDelay = 0; // Frames to wait before turning off
                this.slowMotionDelayFrames = 30; // ~0.5 seconds at 60fps
                this.playerDistances = new Map(); // Track previous distances

                this.gameState = 'TEAMS'; // 'TEAMS', 'TRANSITION', 'APEX'

                // Phase 2: Circular Arena State
                this.arenaCenter = { x: 0, y: 0 };
                this.arenaRadius = 0;
                this.arenaBaseRadius = 0;
                this.lastEliminationTime = 0;
                this.trailblazerTrails = []; // [{x, y, playerId, timestamp}, ...]
                this.deathOrderCounter = 0; // Track order of eliminations for resurrection

                window.addEventListener('resize', () => this.resize());
                this.resize();

                // Bind UI
                $('start-btn').onclick = () => this.start();
                $('restart-btn').onclick = () => this.reset();
                $('import-btn').onclick = () => $('csv-input').click();
                $('csv-input').onchange = (e) => this.handleFileUpload(e);

                this.loop = this.loop.bind(this);
                requestAnimationFrame(this.loop);
            }

            resize() {
                this.width = window.innerWidth;
                this.height = window.innerHeight;

                this.gameCanvas.width = this.width;
                this.gameCanvas.height = this.height;

                // We don't want to clear paint on resize usually, but for simplicity let's just resize
                // A better approach would be to copy the old canvas, but let's keep it simple
                this.paintCanvas.width = this.width;
                this.paintCanvas.height = this.height;
            }

            reset() {
                this.running = false;
                $('setup-panel').classList.remove('hidden');
                $('win-overlay').classList.add('hidden');
                $('hud-top').classList.remove('visible');
                $('phase-indicator').style.display = 'none';

                // Clear Everything
                this.pCtx.clearRect(0, 0, this.width, this.height);
                this.gCtx.clearRect(0, 0, this.width, this.height);
                $('kill-feed').innerHTML = '';
            }

            start() {
                const playerEntries = $('name-input').value.split('\n').filter(n => n.trim().length > 0);
                if (playerEntries.length < 2) return alert("NEED MORE PLAYERS");

                this.players = [];
                this.gameState = 'TEAMS';
                this.trailblazerTrails = [];

                // Shuffle names to randomize teams
                const shuffledEntries = this.shuffleArray([...playerEntries]);
                const mid = Math.ceil(shuffledEntries.length / 2);

                shuffledEntries.forEach((entry, index) => {
                    const team = index < mid ? 'cyan' : 'magenta';
                    let id, name;
                    const parts = entry.split(',').map(p => p.trim());
                    if (parts.length === 2) {
                        id = parts[0];
                        name = parts[1];
                    } else {
                        id = `P${index + 1}`;
                        name = parts[0];
                    }

                    const pos = this.getSafeSpawnPosition(this.players);
                    if (pos) {
                        this.players.push(new Player(id, name, pos.x, pos.y, team));
                    } else {
                        this.players.push(new Player(id, name, rand(100, this.width - 100), rand(100, this.height - 100), team));
                    }
                });

                $('setup-panel').classList.add('hidden');
                $('hud-top').classList.add('visible');
                this.updateCount();

                this.gracePeriod = 300; // 5 seconds approx at 60fps
                this.updatePhaseUI();

                this.running = true;
            }

            updatePhaseUI() {
                const el = $('phase-indicator');
                if (this.gracePeriod > 0) {
                    el.innerText = "PREPAREZ VOUS !"; // WARMUP
                    el.style.color = CONFIG.colors[2]; // Green
                    el.style.display = 'block';
                } else {
                    el.innerText = "COMBAT"; // FIGHT
                    el.style.color = CONFIG.colors[0]; // Red
                    setTimeout(() => el.style.display = 'none', 1000);
                }
            }

            getSafeSpawnPosition(existingPlayers) {
                const maxAttempts = 100;
                const buffer = 50; // Extra space between balls

                for (let i = 0; i < maxAttempts; i++) {
                    const x = rand(100, this.width - 100);
                    const y = rand(100, this.height - 100);

                    let valid = true;
                    for (let p of existingPlayers) {
                        const dist = Math.hypot(x - p.x, y - p.y);
                        // 2 * radius + buffer
                        if (dist < (CONFIG.radius * 2) + buffer) {
                            valid = false;
                            break;
                        }
                    }

                    if (valid) return { x, y };
                }
                return null; // Failed to find spot
            }

            updateCount() {
                const alive = this.players.filter(p => !p.dead).length;
                $('alive-cnt').innerText = `${alive} RESTANTS`;
            }

            logKill(winner, loser) {
                const div = document.createElement('div');
                div.className = 'kill-msg';
                div.style.borderColor = winner.color;
                div.innerHTML = `<span style="color:${winner.color}">${winner.name}</span> SPLATTED <span style="color:#888">${loser.name}</span>`;
                $('kill-feed').prepend(div);
                setTimeout(() => div.remove(), 4000);
            }

            loop() {
                // Clear Game Canvas only (Paint persists)
                this.gCtx.clearRect(0, 0, this.width, this.height);

                if (this.running) {
                    // Game Logic
                    if (this.gracePeriod > 0) {
                        this.gracePeriod--;
                        if (this.gracePeriod === 0) this.updatePhaseUI();
                    }

                    // Check for slow-motion trigger (under 10 players)
                    this.updateSlowMotion();

                    // Apply slow-motion by running updates multiple times or adjusting speeds
                    const updateIterations = this.slowMotion ? 1 : 1;
                    const speedMultiplier = this.slowMotion ? this.slowMotionFactor : 1.0;

                    this.players.forEach(p => p.update(this, speedMultiplier));
                    this.checkCollisions();

                    // APEX: Update arena shrinking and draw circular boundary
                    if (this.gameState === 'APEX') {
                        this.updateArenaShrinking();
                        this.updateApexMechanics();
                        this.drawCircularArena();
                        this.drawTrailblazerTrails();
                    }

                    // Render Players
                    this.players.forEach(p => p.draw(this.gCtx));
                }

                // Render Particles (Transient)
                this.gCtx.globalCompositeOperation = 'lighter';
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.update();
                    p.draw(this.gCtx);
                    if (p.life <= 0) this.particles.splice(i, 1);
                }
                this.gCtx.globalCompositeOperation = 'source-over';

                requestAnimationFrame(this.loop);
            }

            updateSlowMotion() {
                const active = this.players.filter(p => !p.dead);

                // Only when under 10 players and combat has started, and NOT in transition
                if (active.length >= 10 || this.gracePeriod > 0 || this.gameState === 'TRANSITION') {
                    this.slowMotion = false;
                    this.playerDistances.clear();
                    return;
                }

                let shouldSlowDown = false;
                const dangerThreshold = this.gameState === 'TEAMS' ? 60 : 100; // Increased distance threshold for APEX

                // Check all pairs of players
                for (let i = 0; i < active.length; i++) {
                    for (let j = i + 1; j < active.length; j++) {
                        const p1 = active[i];
                        const p2 = active[j];

                        // Skip slow-motion for teammates
                        if (this.gameState === 'TEAMS' && p1.team === p2.team) continue;

                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const dist = Math.hypot(dx, dy);

                        // Create unique pair ID
                        const pairId = `${p1.id}_${p2.id}`;
                        const prevDist = this.playerDistances.get(pairId);

                        // Store current distance
                        this.playerDistances.set(pairId, dist);

                        // Check if players are close AND getting closer
                        if (dist < dangerThreshold && prevDist !== undefined && dist < prevDist) {
                            shouldSlowDown = true;
                        }
                    }
                }

                // Handle slow-motion state with delay
                if (shouldSlowDown) {
                    this.slowMotion = true;
                    this.slowMotionDelay = this.slowMotionDelayFrames; // Reset delay
                } else if (this.slowMotion) {
                    // Countdown delay before turning off
                    this.slowMotionDelay--;
                    if (this.slowMotionDelay <= 0) {
                        this.slowMotion = false;
                    }
                }
            }

            checkCollisions() {
                const active = this.players.filter(p => !p.dead);

                for (let i = 0; i < active.length; i++) {
                    for (let j = i + 1; j < active.length; j++) {
                        const p1 = active[i];
                        const p2 = active[j];

                        const dx = p1.x - p2.x;
                        const dy = p1.y - p2.y;
                        const dist = Math.hypot(dx, dy);
                        const minDist = p1.radius + p2.radius;

                        if (dist < minDist) {
                            if (this.gracePeriod > 0) {
                                // Elastic Collision (Peace Phase)
                                this.resolveElastic(p1, p2, dx, dy, dist);
                            } else {
                                // Combat Phase - Depends on Game State
                                if (this.gameState === 'TEAMS') {
                                    if (p1.team === p2.team) {
                                        this.resolveElastic(p1, p2, dx, dy, dist);
                                    } else {
                                        if (p1.cooldown <= 0 && p2.cooldown <= 0) {
                                            this.resolveCombat(p1, p2);
                                        }
                                    }
                                } else if (this.gameState === 'APEX') {
                                    if (p1.cooldown <= 0 && p2.cooldown <= 0) {
                                        this.resolveApexCombat(p1, p2);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            resolveElastic(p1, p2, dx, dy, dist) {
                // 1. Separate circles to prevent sticky glitches
                const overlap = (p1.radius + p2.radius - dist) / 2;
                const offsetX = (dx / dist) * overlap;
                const offsetY = (dy / dist) * overlap;

                p1.x += offsetX;
                p1.y += offsetY;
                p2.x -= offsetX;
                p2.y -= offsetY;

                // 2. Reflect Velocity (Elastic Collision)
                // Normal vector
                const nx = dx / dist;
                const ny = dy / dist;

                // Relative velocity
                const dvx = p1.vx - p2.vx;
                const dvy = p1.vy - p2.vy;

                // Velocity along normal
                const velAlongNormal = dvx * nx + dvy * ny;

                // Do not resolve if velocities are separating
                if (velAlongNormal > 0) return;

                // Restitution (bounciness) 1 = perfect elastic
                const restitution = 1;

                // Impulse scalar
                const j = -(1 + restitution) * velAlongNormal / 2; // /2 assuming equal mass

                // Apply impulse
                p1.vx += j * nx;
                p1.vy += j * ny;
                p2.vx -= j * nx;
                p2.vy -= j * ny;
            }

            resolveCombat(p1, p2) {
                // RNG Winner
                const winner = Math.random() > 0.5 ? p1 : p2;
                const loser = winner === p1 ? p2 : p1;

                // Eliminate Loser
                loser.dead = true;
                loser.deathOrder = ++this.deathOrderCounter; // Track when they died

                // HUGE SPLAT
                this.drawSplat(loser.x, loser.y, loser.color, 80, 50); // Big messy splat
                this.spawnParticles(loser.x, loser.y, loser.color, 30); // Sparks

                // Buff Winner
                winner.radius += 5;
                winner.cooldown = 20;

                // Bounce Winner
                const angle = Math.atan2(winner.y - loser.y, winner.x - loser.x);
                winner.vx = Math.cos(angle) * 8;
                winner.vy = Math.sin(angle) * 8;

                this.logKill(winner, loser);
                this.updateCount();

                // Check Win conditions
                const active = this.players.filter(p => !p.dead);

                if (this.gameState === 'TEAMS') {
                    const teamsRemaining = new Set(active.map(p => p.team));
                    if (teamsRemaining.size === 1) {
                        this.transitionToPhase2();
                    }
                } else if (this.gameState === 'APEX' && active.length === 1) {
                    this.endGame(active[0]);
                }
            }

            endGame(winner) {
                this.running = false;
                setTimeout(() => {
                    $('win-title').innerHTML = winner.name + "<br>WINS";
                    $('win-title').style.textShadow = `10px 10px 0px ${winner.color}`;
                    $('win-overlay').classList.remove('hidden');
                    $('win-overlay').classList.add('visible');

                    // Final celebration splats
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => {
                            this.drawSplat(
                                rand(this.width * 0.2, this.width * 0.8),
                                rand(this.height * 0.2, this.height * 0.8),
                                winner.color, 120, 100
                            );
                        }, i * 200);
                    }
                }, 1000);
            }

            transitionToPhase2() {
                this.gameState = 'TRANSITION';
                const el = $('phase-indicator');
                el.innerText = "PHASE 2";
                el.style.color = '#FFFFFF';
                el.style.display = 'block';
                el.style.fontSize = '5rem';
                el.style.width = '100%';
                el.style.textAlign = 'center';

                // Wait 3 seconds, then cull and setup arena
                setTimeout(() => {
                    // Get the winning team
                    const survivors = this.players.filter(p => !p.dead);
                    const winningTeam = survivors[0].team;

                    // Get ALL players from the winning team (alive and dead)
                    const winningTeamPlayers = this.players.filter(p => p.team === winningTeam);

                    // Sort: alive players first (deathOrder=0), then most recently dead (higher deathOrder = died later)
                    winningTeamPlayers.sort((a, b) => {
                        // Alive players come first
                        if (a.deathOrder === 0 && b.deathOrder !== 0) return -1;
                        if (a.deathOrder !== 0 && b.deathOrder === 0) return 1;
                        // Among alive, sort by radius (largest first)
                        if (a.deathOrder === 0 && b.deathOrder === 0) return b.radius - a.radius;
                        // Among dead, sort by deathOrder descending (most recently dead first)
                        return b.deathOrder - a.deathOrder;
                    });

                    // Take top 8 (or all if fewer than 8)
                    const top8 = winningTeamPlayers.slice(0, 8);
                    const eliminated = winningTeamPlayers.slice(8);

                    // Resurrect dead players in top 8
                    top8.forEach(p => {
                        if (p.dead) {
                            p.dead = false;
                            p.deathOrder = 0;
                            p.radius = CONFIG.radius; // Reset to base size
                            // Spawn particles to show resurrection
                            this.spawnParticles(p.x, p.y, '#FFFFFF', 20);
                        }
                    });

                    // Kill players not in top 8 (from winning team) with splats
                    eliminated.forEach(p => {
                        if (!p.dead) {
                            p.dead = true;
                            this.drawSplat(p.x, p.y, p.color, 60, 30);
                        }
                    });

                    // Also mark all non-winning team players as dead (they should already be)
                    this.players.filter(p => p.team !== winningTeam).forEach(p => p.dead = true);

                    // Assign roles to top 8
                    const roleKeys = Object.keys(ROLES);
                    const shuffledRoles = this.shuffleArray([...roleKeys]);

                    top8.forEach((player, index) => {
                        const roleKey = shuffledRoles[index];
                        const role = ROLES[roleKey];

                        player.role = roleKey;
                        player.emoji = role.emoji;
                        player.color = role.color;
                        player.team = null; // Everyone is an enemy

                        // Role-specific initialization
                        if (roleKey === 'tank') {
                            player.lives = 3;
                        }
                        player.ninjaSwapCooldown = 0;
                        player.glitchTeleportCooldown = APEX_CONFIG.glitchTeleportInterval;
                        player.ghostInvincible = false;
                        player.ghostInvincibleTime = 0;
                        player.trailPoints = []; // For trailblazer

                        // Teleport to center
                        player.x = this.width / 2 + rand(-30, 30);
                        player.y = this.height / 2 + rand(-30, 30);

                        // Give random velocity
                        const angle = Math.random() * Math.PI * 2;
                        const speed = rand(CONFIG.minSpeed, CONFIG.maxSpeed);
                        player.vx = Math.cos(angle) * speed;
                        player.vy = Math.sin(angle) * speed;
                    });

                    // Setup circular arena
                    this.arenaCenter = { x: this.width / 2, y: this.height / 2 };
                    this.arenaBaseRadius = this.height * 0.50;
                    this.arenaRadius = this.arenaBaseRadius;
                    this.lastEliminationTime = Date.now();

                    this.updateCount();

                    el.innerText = "THE APEX ARENA";
                    el.style.color = '#FFD700';
                    setTimeout(() => {
                        el.style.display = 'none';
                        this.gameState = 'APEX';
                    }, 2000);
                }, 3000);
            }

            updateArenaShrinking() {
                const now = Date.now();
                if (now - this.lastEliminationTime > APEX_CONFIG.stalemateTime) {
                    // Shrink the arena
                    const shrinkPerFrame = APEX_CONFIG.shrinkRate * (16 / 1000); // ~16ms per frame
                    this.arenaRadius = Math.max(80, this.arenaRadius - shrinkPerFrame);
                }
            }

            updateApexMechanics() {
                const active = this.players.filter(p => !p.dead && p.role);
                const now = Date.now();

                active.forEach(player => {
                    // Glitch teleportation
                    if (player.role === 'glitch') {
                        player.glitchTeleportCooldown--;
                        if (player.glitchTeleportCooldown <= 0) {
                            // Teleport to random position inside circle
                            const angle = Math.random() * Math.PI * 2;
                            const dist = Math.random() * (this.arenaRadius - player.radius - 20);
                            player.x = this.arenaCenter.x + Math.cos(angle) * dist;
                            player.y = this.arenaCenter.y + Math.sin(angle) * dist;
                            player.glitchTeleportCooldown = APEX_CONFIG.glitchTeleportInterval;
                            this.spawnParticles(player.x, player.y, player.color, 15);
                        }
                    }

                    // Ninja swap detection
                    if (player.role === 'ninja' && player.ninjaSwapCooldown <= 0) {
                        for (const other of active) {
                            if (other === player || other.ghostInvincible) continue;
                            const dist = Math.hypot(player.x - other.x, player.y - other.y);
                            if (dist < APEX_CONFIG.ninjaSwapRange) {
                                // Swap positions
                                const tempX = player.x, tempY = player.y;
                                player.x = other.x;
                                player.y = other.y;
                                other.x = tempX;
                                other.y = tempY;
                                player.ninjaSwapCooldown = APEX_CONFIG.ninjaSwapCooldown;
                                this.spawnParticles(player.x, player.y, player.color, 10);
                                this.spawnParticles(other.x, other.y, player.color, 10);
                                break;
                            }
                        }
                    }
                    if (player.ninjaSwapCooldown > 0) player.ninjaSwapCooldown--;

                    // Vampire aura
                    if (player.role === 'vampire') {
                        for (const other of active) {
                            if (other === player || other.ghostInvincible) continue;
                            const dist = Math.hypot(player.x - other.x, player.y - other.y);
                            if (dist < APEX_CONFIG.vampireAuraRadius) {
                                if (Math.random() < APEX_CONFIG.vampireDeathChance) {
                                    // Heart attack!
                                    this.killPlayer(other, player, 'HEART ATTACK');
                                }
                            }
                        }
                    }

                    // Trailblazer trail
                    if (player.role === 'trailblazer') {
                        // Add current position to trail
                        this.trailblazerTrails.push({
                            x: player.x,
                            y: player.y,
                            playerId: player.id,
                            timestamp: now,
                            color: player.color
                        });

                        // Check if enemies touch trail
                        for (const other of active) {
                            if (other === player || other.ghostInvincible) continue;
                            for (const point of this.trailblazerTrails) {
                                if (point.playerId === player.id) {
                                    const dist = Math.hypot(other.x - point.x, other.y - point.y);
                                    if (dist < other.radius + 5) {
                                        this.killPlayer(other, player, 'TOXIC TRAIL');
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    // Ghost invincibility countdown
                    if (player.ghostInvincible) {
                        player.ghostInvincibleTime--;
                        if (player.ghostInvincibleTime <= 0) {
                            player.ghostInvincible = false;
                        }
                    }
                });

                // Clean up old trail points
                this.trailblazerTrails = this.trailblazerTrails.filter(
                    point => now - point.timestamp < APEX_CONFIG.trailLifetime * (1000 / 60)
                );
            }

            killPlayer(victim, killer, deathMessage = 'SPLATTED') {
                if (victim.dead || victim.ghostInvincible) return;

                // Ghost survival chance
                if (victim.role === 'ghost' && Math.random() < 0.5) {
                    victim.ghostInvincible = true;
                    victim.ghostInvincibleTime = APEX_CONFIG.ghostInvincibleTime;
                    this.spawnParticles(victim.x, victim.y, '#FFFFFF', 20);
                    return; // Survived!
                }

                // Tank multi-life
                if (victim.role === 'tank' && victim.lives > 1) {
                    victim.lives--;
                    victim.radius = Math.max(15, victim.radius - 5);
                    this.spawnParticles(victim.x, victim.y, victim.color, 15);
                    return; // Survived!
                }

                // Actually die
                victim.dead = true;
                this.drawSplat(victim.x, victim.y, victim.color, 80, 50);
                this.spawnParticles(victim.x, victim.y, victim.color, 30);

                // Log kill with custom message
                const div = document.createElement('div');
                div.className = 'kill-msg';
                div.style.borderColor = killer.color;
                div.innerHTML = `<span style="color:${killer.color}">${killer.emoji} ${killer.name}</span> ${deathMessage} <span style="color:#888">${victim.emoji} ${victim.name}</span>`;
                $('kill-feed').prepend(div);
                setTimeout(() => div.remove(), 4000);

                // Martyr revenge
                if (victim.role === 'martyr' && killer && killer !== victim) {
                    setTimeout(() => {
                        if (!killer.dead) {
                            killer.dead = true;
                            this.drawSplat(killer.x, killer.y, '#FF6600', 100, 60);
                            this.spawnParticles(killer.x, killer.y, '#FF6600', 40);

                            const vengDiv = document.createElement('div');
                            vengDiv.className = 'kill-msg';
                            vengDiv.style.borderColor = '#FF6600';
                            vengDiv.innerHTML = `<span style="color:#FF6600">ðŸ’£ ${victim.name}</span> MARTYRDOM <span style="color:#888">${killer.emoji} ${killer.name}</span>`;
                            $('kill-feed').prepend(vengDiv);
                            setTimeout(() => vengDiv.remove(), 4000);
                            this.updateCount();
                        }
                    }, 100);
                }

                // Buff killer
                if (killer && killer !== victim) {
                    killer.radius += 3;
                    killer.cooldown = 20;
                }

                this.lastEliminationTime = Date.now();
                this.updateCount();

                // Check win condition
                const active = this.players.filter(p => !p.dead);
                if (active.length === 1) {
                    this.endGame(active[0]);
                }
            }

            resolveApexCombat(p1, p2) {
                // Skip if either is invincible (ghost)
                if (p1.ghostInvincible || p2.ghostInvincible) {
                    // Just elastic bounce
                    const dx = p1.x - p2.x;
                    const dy = p1.y - p2.y;
                    const dist = Math.hypot(dx, dy);
                    this.resolveElastic(p1, p2, dx, dy, dist);
                    return;
                }

                // Calculate win probability
                let p1WinChance = 0.5;
                let p2WinChance = 0.5;

                if (p1.role === 'assassin') p1WinChance = 0.8;
                if (p2.role === 'assassin') p2WinChance = 0.8;

                // Normalize
                const total = p1WinChance + p2WinChance;
                p1WinChance /= total;

                const winner = Math.random() < p1WinChance ? p1 : p2;
                const loser = winner === p1 ? p2 : p1;

                this.killPlayer(loser, winner);

                // Bounce winner away
                const angle = Math.atan2(winner.y - loser.y, winner.x - loser.x);
                winner.vx = Math.cos(angle) * 8;
                winner.vy = Math.sin(angle) * 8;
            }

            drawCircularArena() {
                const ctx = this.gCtx;
                const cx = this.arenaCenter.x;
                const cy = this.arenaCenter.y;
                const r = this.arenaRadius;

                ctx.save();
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#FFFFFF';

                // Draw jagged chalk circle - multiple layers
                for (let layer = 0; layer < 2; layer++) {
                    ctx.strokeStyle = layer === 0 ? 'rgba(255,255,255,0.9)' : 'rgba(255,255,255,0.4)';
                    ctx.lineWidth = layer === 0 ? 4 : 8;
                    ctx.beginPath();

                    const segments = 60;
                    const jitter = layer === 0 ? 4 : 8;

                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        const jitterR = r + rand(-jitter, jitter);
                        const px = cx + Math.cos(angle) * jitterR;
                        const py = cy + Math.sin(angle) * jitterR;

                        if (i === 0) {
                            ctx.moveTo(px, py);
                        } else {
                            ctx.lineTo(px, py);
                        }
                    }

                    ctx.closePath();
                    ctx.stroke();
                }

                // Draw shrinking indicator if shrinking
                const now = Date.now();
                if (now - this.lastEliminationTime > APEX_CONFIG.stalemateTime) {
                    ctx.strokeStyle = 'rgba(255,0,0,0.6)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 10]);
                    ctx.beginPath();
                    ctx.arc(cx, cy, r - 20, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                ctx.restore();
            }

            drawTrailblazerTrails() {
                if (this.trailblazerTrails.length === 0) return;

                const ctx = this.gCtx;
                ctx.save();
                ctx.shadowBlur = 10;
                ctx.shadowColor = ROLES.trailblazer.color;

                this.trailblazerTrails.forEach(point => {
                    const age = (Date.now() - point.timestamp) / (APEX_CONFIG.trailLifetime * (1000 / 60));
                    const alpha = 1 - age;
                    ctx.globalAlpha = alpha * 0.7;
                    ctx.fillStyle = point.color;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.globalAlpha = 1;
                ctx.restore();
            }

            drawSplat(x, y, color, size, count) {
                const ctx = this.pCtx;
                ctx.fillStyle = color;

                // Main blob
                ctx.beginPath();
                ctx.arc(x, y, size * 0.4, 0, Math.PI * 2);
                ctx.fill();

                // Random splatters around
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * size;
                    const r = Math.random() * (size * 0.2);

                    ctx.beginPath();
                    ctx.arc(
                        x + Math.cos(angle) * dist,
                        y + Math.sin(angle) * dist,
                        r, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
            }

            spawnParticles(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    this.particles.push(new Particle(x, y, color));
                }
            }

            async handleFileUpload(e) {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;

                const allPlayerEntries = [];

                for (const file of files) {
                    const text = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (event) => resolve(event.target.result);
                        reader.onerror = (error) => reject(error);
                        reader.readAsText(file);
                    });

                    const lines = text.split('\n').filter(line => line.trim().length > 0);
                    if (lines.length < 2) continue;

                    // Parse header to find column indices
                    const header = lines[0].split(',').map(col => col.replace(/"/g, '').trim());
                    const orderIdIndex = header.indexOf('Order ID');
                    const billingNameIndex = header.indexOf('Billing Name');

                    if (orderIdIndex === -1 || billingNameIndex === -1) {
                        console.warn(`File ${file.name} missing required columns.`);
                        continue;
                    }

                    // Process each data row (skip header)
                    for (let i = 1; i < lines.length; i++) {
                        const row = this.parseCSVLine(lines[i]);
                        if (row.length <= Math.max(orderIdIndex, billingNameIndex)) continue;

                        let orderId = row[orderIdIndex].replace(/"/g, '').trim();
                        const billingName = row[billingNameIndex].replace(/"/g, '').trim();

                        if (!billingName || !orderId) continue;

                        // Remove leading zeros from order ID
                        orderId = parseInt(orderId, 10).toString();

                        // Parse the name
                        const nameParts = billingName.split(' ').filter(p => p.length > 0);
                        if (nameParts.length === 0) continue;

                        const firstName = nameParts[0];
                        const lastPart = nameParts.length > 1 ? nameParts[nameParts.length - 1] : '';
                        const firstLetter = firstName.charAt(0).toUpperCase();

                        const displayName = firstName;
                        const formattedEntry = `${displayName} ${firstLetter}#${orderId}`;

                        allPlayerEntries.push(formattedEntry);
                    }
                }

                if (allPlayerEntries.length === 0) {
                    alert('No valid player entries found in selected files');
                } else {
                    const currentText = $('name-input').value.trim();
                    const newText = currentText ? currentText + '\n' + allPlayerEntries.join('\n') : allPlayerEntries.join('\n');
                    $('name-input').value = newText;
                }

                // Reset file input
                e.target.value = '';
            }

            parseCSVLine(line) {
                // Simple CSV parser that handles quoted fields
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];

                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current);
                        current = '';
                    } else {
                        current += char;
                    }
                }

                result.push(current); // Add last field
                return result;
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
        }

        class Player {
            constructor(id, name, x, y, team = null) {
                this.id = id;
                this.name = name;
                this.radius = CONFIG.radius;
                this.team = team;
                this.color = team ? CONFIG.crews[team] : randColor();
                this.x = x;
                this.y = y;

                const angle = Math.random() * Math.PI * 2;
                const speed = rand(CONFIG.minSpeed, CONFIG.maxSpeed);
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;

                this.dead = false;
                this.cooldown = 0;
                this.deathOrder = 0; // 0 = alive, higher = died earlier

                // Phase 2: Role properties
                this.role = null;
                this.emoji = '';
                this.lives = 1;
                this.ninjaSwapCooldown = 0;
                this.glitchTeleportCooldown = 0;
                this.ghostInvincible = false;
                this.ghostInvincibleTime = 0;
            }

            update(game, speedMultiplier = 1.0) {
                if (this.dead) return;

                // Move (with slow-motion support)
                this.x += this.vx * speedMultiplier;
                this.y += this.vy * speedMultiplier;

                // Boundary handling depends on game state
                if (game.gameState === 'APEX' && game.arenaRadius > 0) {
                    // CIRCULAR BOUNDARY - Bounce off inside of circle
                    const dx = this.x - game.arenaCenter.x;
                    const dy = this.y - game.arenaCenter.y;
                    const dist = Math.hypot(dx, dy);

                    if (dist + this.radius > game.arenaRadius) {
                        // Calculate normal (pointing toward center)
                        const nx = -dx / dist;
                        const ny = -dy / dist;

                        // Position: push back inside
                        const overflow = dist + this.radius - game.arenaRadius;
                        this.x += nx * overflow;
                        this.y += ny * overflow;

                        // Reflect velocity off the tangent (bounce)
                        const dot = this.vx * nx + this.vy * ny;
                        this.vx -= 2 * dot * nx;
                        this.vy -= 2 * dot * ny;
                    }
                } else {
                    // RECTANGULAR BOUNDARY - Standard wall bounce
                    if (this.x < this.radius) { this.x = this.radius; this.vx *= -1; }
                    if (this.x > game.width - this.radius) { this.x = game.width - this.radius; this.vx *= -1; }
                    if (this.y < this.radius) { this.y = this.radius; this.vy *= -1; }
                    if (this.y > game.height - this.radius) { this.y = game.height - this.radius; this.vy *= -1; }
                }

                // Paint Trail (Frequency check to save perf if needed, but per-frame is smoother)
                if (Math.random() > 0.1) {
                    game.pCtx.fillStyle = this.color;
                    game.pCtx.beginPath();
                    game.pCtx.arc(this.x, this.y, this.radius * 0.8, 0, Math.PI * 2);
                    game.pCtx.fill();

                    // Occasional drip
                    if (Math.random() > 0.9) {
                        game.pCtx.beginPath();
                        game.pCtx.arc(
                            this.x + rand(-10, 10),
                            this.y + rand(-10, 10),
                            rand(2, 6), 0, Math.PI * 2
                        );
                        game.pCtx.fill();
                    }
                }

                if (this.cooldown > 0) this.cooldown--;
            }

            draw(ctx) {
                if (this.dead) return;

                // Draw Character (Spray Can Top look)
                ctx.save();
                ctx.translate(this.x, this.y);

                // Ghost transparency when invincible
                if (this.ghostInvincible) {
                    ctx.globalAlpha = 0.3;
                }

                // Glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.color;

                // Core
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Inner Color
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.7, 0, Math.PI * 2);
                ctx.fill();

                // Tank lives indicator
                if (this.role === 'tank' && this.lives > 1) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('x' + this.lives, 0, 0);
                }

                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;

                // Emoji above (if has role)
                if (this.emoji) {
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(this.emoji, 0, -this.radius - 22);
                }

                // Name
                ctx.fillStyle = "#fff";
                ctx.font = "bold 14px 'Audiowide', sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText(this.name, 0, -this.radius - 8);

                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = rand(2, 8);
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.size = rand(2, 6);
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.03;
                this.size *= 0.95;
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        // Init
        new Game();
    </script>
</body>

</html>